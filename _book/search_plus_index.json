{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction ENS中文文档 概述 开始 ENS介绍 专业术语 常见问题 ENS部署情况 注册器常见问题 在私有链上部署ENS DNS注册器指南 漏洞奖金计划 ENS改进提案 ENSIP-1: ENS ENSIP-2: 初始哈希注册器 ENSIP-3: 反向解析 ENSIP-4: 合约 ABI 支持 ENSIP-5: 文本记录 ENSIP-6: ENS 中的 DNS ENSIP-7: 内容哈希字段 ENSIP-8: 接口发现 ENSIP-9: 多链地址解析 ENSIP-10: 通配符解析 ENSIP-11: 兼容链地址解析 ENSIP-12: 头像文本记录 DAPP开发指南 在 DAPP 中启用 ENS ENS 库 ENS 的使用 名称解析 名称管理 名称注册和续费 ENS 前端设计指南 ENS 作为一种 NFT L2 和链下数据支持 合约 API 参考 ENS 合约概述 名称处理 注册表 反向注册器 测试注册器 公共解析器 .eth 永久注册器 .eth 永久注册器的实现 .eth 永久注册器的控制器 DNS 注册器 合约开发指南 链上名称解析 编写一个解析器 编写一个注册器 ENS 迁移(2020年2月) DApp 开发者迁移指南 技术说明 © Pengfei Ni all right reserved，powered by GitbookUpdated at 2022-05-17 21:05:15 "},"docs/readme.html":{"url":"docs/readme.html","title":"概述","keywords":"","body":"以太坊名称服务（Ethereum Name Service，简称 ENS）是一个基于以太坊区块链的分布式、开放和可扩展的命名系统。 ENS 的工作是将可读的名称（比如 “alice.eth”）解析为计算机可以识别的标识符，如以太坊地址、其他加密货币地址、内容的哈希、元数据等。ENS 还支持 “反向解析”，这使得将元数据(如规范化名称或接口描述)与以太坊地址相关联成为可能。 ENS 的目标与 DNS（互联网名称服务）类似，但由于以太坊区块链的功能特点和限制条件，两者架构有很大的不同。与 DNS 一样，ENS 是一个层次结构的名称系统，不同层次名称之间以点作为分隔符，我们把层次的名称叫做域，一个域的所有者能够完全控制其子域。 顶级名称（比如 “.eth” 和 “.test”）的所有者是一种名为 “注册器（registrar）” 的智能合约，该合约内指定了控制子名称分配的规则。任何人都可以按照这些合约规定的规则，获得一个名称的所有权并为自己所用。ENS 还支持用户将自己拥有的 DNS 域名接入到 ENS 中使用。 由于 ENS 的层次性，不论一个人拥有哪个级别的名称，都可以根据需要为自己或他人配置子名称。例如，如果 Alice 拥有 “alice.eth”，她就可以创建 “pay.alice.eth” 并按需对其进行设置。 ENS 部署在以太坊主网络和几个测试网络上。如果你使用 ensjs Javascript 库或终端用户应用程序，它将自动检测与你交互的网络并在该网络上部署 ENS。 你现在就可以通过 ENS APP 或 ENS 官方主页 上的 ENS 应用程序，来试用 ENS。 ENS 架构 ENS 有两个主要组件：注册表 和 解析器。 ENS 注册表是一个智能合约，该合约维护所有名称和子名称列表，并存储关于每个名称的三个关键信息: 名称的所有者 名称的解析器 名称下所有记录的缓存存活时间（即 TTL） 名称的所有者可以是外部帐户（用户）或智能合约。注册器就是一个拥有顶级名称的智能合约，并按照合约中的规则将该名称的子名称分发给用户。 ENS 注册表中的名称所有者可以: 为名称设置解析器和 TTL 将名称的所有权转让给另一个地址 更改子名称的所有权 ENS 注册表非常简单，它的存在只是为了将名称映射到负责解析这个名称的解析器。 解析器负责将名称转换为地址。只要是符合解析器相关标准的智能合约，都可以在 ENS 中作为解析器程序。通用解析器服务于需求简单的用户，比如不经常更改地址的用户。 每个记录类型（以太坊地址、内容哈希等）都定义了一个或多个方法，解析器必须实现这些方法才能提供这类记录。新的记录类型可以随时通过 EIP 标准化程序进行定义，因此不需要为了支持它们而对 ENS 注册表或现有的解析器进行更改。 在 ENS 中解析一个名称需要两个步骤：首先，询问注册表是哪个解析器负责解析该名称，然后，向该解析器查询解析结果。 在上面的例子中，我们想找到 “foo.eth” 指向的以太坊地址。首先，我们询问注册表是哪个解析器负责解析 “foo.eth” ；然后，我们向该解析器查询 “foo.eth” 的地址。 Namehash 智能合约中的资源限制使得直接与可读的名称交互效率低下，因此ENS只使用固定长度的256位加密哈希。为了从名称生成哈希的同时仍然保留其层次性，ENS 使用了名为 Namehash 的算法。例如，“alice.eth” 的 Namehash 为 0x787192fc5378cc32aa956ddfdedbf26b24e8d78e40109add0eea2c1a012c3dec ，Namehash 只是用来在 ENS 内部表示名称。 Namehash 是一个递归过程，可以为任何有效的名称生成唯一的哈希。从任意一个名称的 Namehash 开始（比如 “alice.eth” 的 Namehash）可以推导出任意子名称的 Namehash（比如 “iam.alice.eth” 的 Namehash），而且推导过程中不需要知道或处理 “alice.eth” 这个可读的原始名称。正是这个特性使得 ENS 能够成为一个层次性的系统，且不必在内部处理可读的文本字符串。 在使用 Namehash 进行哈希之前，首先需要借助 UTS-46 标准对名称进行规范化，确保名称中的字母与大小写无关，并禁止使用无效字符。任何对名称进行哈希和解析的操作都 必须 首先对其进行规范化，以确保所有用户获得 ENS 的一致性。 有关 Namehash 和规范化如何工作的详细信息，请参阅有关 名称处理 的文档。 开始使用 ENS 为包括 dapp 开发者和合约开发者在内的各种人员提供参考文档。 我是 dapp 的开发者，我想为我的 dapp 添加 ENS 支持 从 在 Dapp 中启用 ENS 开始，查看 dapp 开发者指南，你可以从众多可用的 ENS 库 中选择一个来开始使用 ENS 。 我是一名合约开发者，希望在我的智能合约中与ENS进行交互 从 链上名称解析 开始，查看合约开发者指南。你还可以 编写自己的解析器（自定义查询名称的过程）或自己的 注册器（自定义注册新名称的过程）。 我想查看 ENS 智能合约的参考文档 查看 ENS 智能合约的 API 参考文档，这些文档涵盖了 ENS 的核心合约、注册表、解析器 和常用的注册器，如：测试注册器、反向注册器 以及 .eth注册器。 © Pengfei Ni all right reserved，powered by GitbookUpdated at 2022-05-17 21:04:39 "},"docs/terminology.html":{"url":"docs/terminology.html","title":"ENS介绍","keywords":"","body":" 管理员（controller）：可以设置名称记录的帐户，它可以由注册人或当前管理员来更改。 标签（label）：一个名称的独立组成部分，比如 “alice.eth” 中的 “alice”。 标签哈希（labelhash）：单个标签的 keccak256 哈希。 名称（name）：ENS 标识符，如 “alice.eth”，一个 ENS 名称可能由多个独立部分（标签）组成，标签之间用点分隔。 Namehash：用于处理 ENS 名称并返回唯一标识该名称的加密哈希的算法。Namehash 以名称作为输入，并生成一个 Node（节点）。 节点（node）：唯一标识名称的加密哈希。（译注：节点即是名称经过 Namehash 计算的结果，后文中有些地方的提到的节点，可以理解为 ENS 名称） 所有者（owner）：名称的所有者是 ENS 注册表中的所有者字段引用的实体。所有者可以转让所有权，设置解析器或 TTL，并创建或重新分配子名称。 注册器（registrar）：注册器是负责分配子名称的合约。任何级别的 ENS 名称都可以配置注册器，一个名称的注册器由其在注册表中的登记的所有者来指定。 注册（registration）：注册是注册器对名称所有权的记录。这与注册表中的所有者（owner）字段不同，注册保存在注册器合约中，并附加存储了到期日期、已付费用等信息。 注册人（registrant）：注册的所有者。注册人可进行注册转让（过户）、设置管理员，如果有需要，还可以在注册表中收回名称的所有权。 注册表（registry）：ENS 的核心合约，注册表用来维护名称（不论是哪个级别的名称，如 x，y.x，z.y.x 等）与其所有者之间的映射列表，还维护着名称的解析器和 TTL。 解析器（resolver）：解析器是一个从名称映射到资源（加密货币地址、内容哈希等）的合约，一个名称的解析器由其在注册表中的解析器字段来指定。 © Pengfei Ni all right reserved，powered by GitbookUpdated at 2022-05-17 21:04:39 "},"docs/ens-improvement-proposals/readme.html":{"url":"docs/ens-improvement-proposals/readme.html","title":"ENS改进提案","summary":"Standards documentation describing the ENS protocol","keywords":"","body":"ENS Improvement Proposals © Pengfei Ni all right reserved，powered by GitbookUpdated at 2022-05-17 21:04:39 "},"docs/ens-improvement-proposals/ensip-1-ens.html":{"url":"docs/ens-improvement-proposals/ensip-1-ens.html","title":"ENSIP-1: ENS","summary":"Documentation of the basic ENS protocol (formerly EIP-137).","keywords":"","body":" 作者 Nick Johnson \\arachnid@notdot.net 状态 完结 创建时间 2016-04-04 摘要 这个 ENSIP 描述了以太坊名称服务（Ethereum Name Service）的细节，是一个包含协议及 ABI 定义的提案，它支持将简短的、人类可读的名称灵活地解析至服务和资源标识。用户和开发人员可以引用易读且容易记忆的名称，并允许在底层资源(合约、内容寻址数据等)发生变化时，根据需要更新这些名称。 名称的目标是提供稳定的、人类可读的标识符，用来指向网络资源。通过这种方式，用户可以输入一个容易记住的字符串，例如 vitalik.wallet 或 www.mysite.swarm，并定向到正确的资源。名称和资源之间的映射可能会随着时间的推移而改变，所以用户可能会更改钱包，网站可能会更改主机，文档可能会更新到新版本，而名称不会改变。此外，名称不一定指定单一的资源，通过不同的记录类型允许相同的名称引用不同的资源。例如，浏览器可以通过获取 A（地址）记录将 mysite.swarm 解析至它的服务器 IP 地址，同时邮件客户端可以通过获取邮件服务器的 MX（邮件交换器）记录来将相同的名称解析至邮件服务器。 动机 以太坊中现有的名称解析规范和实现能够提供基本功能，但存在一些缺陷，会在很大程序上限制其长期可用性: 一个全局命名空间，所有名称都有一个 “集中式” 解析器。 有限的支持或完全不支持委托和子名称/子名称。 只有一种记录类型，不支持将多种记录关联至同一个名称。 由于单一的全局实现，因此不支持多个名称分配系统。 合并的职责: 名称解析、注册和 whois 信息。 这些特性支持的用例包括: 支持子名称/子名称，如 live.mysite.tld 和 forum.mysite.tld 单一名称下的多个服务，如托管在 Swarm 的 DApp、Whisper 地址和邮件服务器。 支持 DNS 记录类型，允许区块链托管的“传统”名称。这将允许 Ethereum 客户端（如 Mist）从区块链名称解析至传统网站地址或电子邮件服务器。 DNS 网关，通过 DNS 对接 ENS 名称，为传统客户端解析和连接到区块链服务提供更便利的方法。 特别是前两个用例，在当今的互联网 DNS 下随处可见，我们相信它们是名称服务的基本特性，随着以太坊平台的发展和成熟，它们将继续发挥作用。 本文件的规范性部分没有规定提议系统的实现，它的目的是记录不同解析器的实现可以遵循的协议，以促进的名称解析的一致性。附录提供了解析器合约和库的实现示例，它们仅作为示例来用。 同样，本文档也不会指定应该如何注册或更新名称，或者系统如何查询某个名称的所有者。注册是注册商的工作，也是一个治理问题，在顶级名称之间必然会有所不同。 名称记录的更新也可以与解析分开处理。一些系统，如 Swarm，可能需要一个定义相对完善的接口来更新名称，鉴于此，我们计划为此开发一个标准。 规范 概述 ENS 系统包括三个主要部分: ENS 注册表 解析器 注册器 注册表是一个单独的合约，它支持将任意已注册名称映射到负责这个名称的解析器，并允许名称的所有者设置解析器地址，并创建子域，子域的所有者可以与父域不同。 解析器负责查找一个名称对应的资源——例如，返回一个合约地址、一个内容哈希或一个对应的 IP 地址。解析器规范在这里定义并在其他 ensip 中扩展，定义了解析器可以实现哪些方法来支持解析不同类型的记录。 注册器负责向系统用户分配名称，并且是唯一能够更新 ENS 的实体；ENS 注册表中节点的所有者是其注册器。注册器可以是合约或外部帐户，但根域和顶级域的注册器至少要通过合约来实现。 在 ENS 中解析名称需要两个步骤。首先，利用以下方法对要解析的名称进行哈希处理之后，通过这个哈希调用 ENS 注册表，如果记录存在，注册表将返回其解析器的地址。然后，使用与请求资源类型对应的方法来调用解析器，解析器返回所需的结果。 例如，假设您希望找到与 “beercoin.eth” 相关联的合约地址。首先，获取解析器: var node = namehash(\"beercoin.eth\"); var resolver = ens.resolver(node); 然后，向解析器请求合约地址: var address = resolver.addr(node); 由于 “namehash” 过程只依赖于名称本身，因此可以预先计算并插入到合约中，从而不必再进行字符串操作，并且无论原始名称中有几级组件，都可以对 ENS 记录进行 O(1) 查找。 语法 ENS 名称必需符合以下语法 ::= | \".\" ::= 任意符合 UTS46 标准的字符串标签 简而言之，名称由一系列以点分隔的标签构成。每个标签都必须是有效的标准化标签，符合 transitional=false 和 useSTD3AsciiRules=true 条件下的 UTS46 规范。对于 Javascript 的实现，可以使用一个库来规范和检查名称。 需要注意的是，虽然名称中允许使用大写和小写字母，但 UTS46 规范化会在对标签进行哈希之前先对其进行大小写合并（译注，实际上就是会全部转换为小写字母），因此大小写不同但拼写相同的两个名称将产生相同的名称哈希。 标签和域可以是任意长度，但为了与传统 DNS 兼容，建议每个标签限制为不超过 64 个字符，完成的 ENS 名称不超过 255 个字符。出于同样的原因，建议标签不要以连字符开头或结尾，也不要以数字开头。 namehash 算法 一个名称在 ENS 中使用之前，先使用 namehash 算法进行哈希处理。该算法对一个名称的各个组成部分进行递归式哈希，为任何有效的输入域生成一个唯一的、固定长度的字符串。namehash 的输出称为 “节点”。 namehash 算法的伪代码如下: def namehash(name): if name == '': return '\\0' * 32 else: label, _, remainder = name.partition('.') return sha3(namehash(remainder) + sha3(label)) 简单来说，名称被分成一个或多个标签，每个标签都经过哈希处理。然后，从最后一个标签开始，将前一个输出与当前标签的哈希连接并再次进行哈希处理。第一个标签与 32 个 0 字节连接。因此，mysite.swarm 的处理过程如下 node = '\\0' * 32 node = sha3(node + sha3('swarm')) node = sha3(node + sha3('mysite')) namehash 的实现应该匹配以下测试向量: namehash('') = 0x0000000000000000000000000000000000000000000000000000000000000000 namehash('eth') = 0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae namehash('foo.eth') = 0xde9b09fd7c5f901e23a3f19fecc54828e9c848539801e86591bd9801b019f84f 注册表规范 ENS 注册表合约中公开了以下函数: function owner(bytes32 node) constant returns (address); 返回指定节点的所有者（注册器）。 function resolver(bytes32 node) constant returns (address); 返回指定节点的解析器。 function ttl(bytes32 node) constant returns (uint64); 返回节点的 TTL，也就是节点信息可以被缓存的最大时长。 function setOwner(bytes32 node, address owner); 将节点的所有权转移给另一个注册器。此函数只能由 node 的当前所有者调用，此函数被调用成功后会记录事件 Transfer(bytes32 indexed, address)。 function setSubnodeOwner(bytes32 node, bytes32 label, address owner); 创建一个新节点，sha3(node, label) 并将期所有者设置为 owner，而如果该节点已经存在，则会用新的所有者更新这个节点。此函数只能被 node 的当前所有者调用。此函数被调用成功后会记录事件 NewOwner(bytes32 indexed, bytes32 indexed, address)。 function setResolver(bytes32 node, address resolver); 为 node 设置解析器。此函数只能被 node 的当前所有者调用。此函数被调用成功后会记录事件 NewResolver(bytes32 indexed, address)。 function setTTL(bytes32 node, uint64 ttl); 设置节点的 TTL。节点的 TTL 适用于注册表中的“所有者”和“解析器”记录，以及相应解析器返回的任何信息。 解析器规范 解析器可以实现这里指定的记录类型的任意子集。如果记录类型规范要求解析器提供多种功能，则解析器必须实现或者放弃所有功能。解析器必须指定一个回调函数。 解析器具有一项强制性功能: function supportsInterface(bytes4 interfaceID) constant returns (bool) supportsInterface 函数记录在 EIP-165 中，如果解析器实现了某个 4 字节标识符代表的接口，则返回 true。接口标识符由该接口提供的函数的签名哈希的异或组成，在单函数接口情况下，它直接等于该函数的签名哈希。 对于 0x01ffc9a7（即 supportsInterface 自身的接口 ID），supportsInterface 必须返回 true。 下表中指定了当前标准化的解析器接口。 以下接口已经定义: Interface name Interface hash Specification addr 0x3b3b57de Contract address name 0x691f3431 ENSIP-3 ABI 0x2203ab56 ENSIP-4 text 0x59d1d43c ENSIP-5 contenthash 0xbc1c58d1 ENSIP-7 interfaceImplementer 0xb8f2bbb4 ENSIP-8 addr(bytes32,uint256) 0xf1cb7e06 ENSIP-9 ENSIP 可以定义要添加到此注册表的新接口。 合约地址接口 期望支持合约地址资源的解析器必须提供以下功能: function addr(bytes32 node) constant returns (address); 如果解析器支持 addr 查询，但请求的节点没有记录地址，那么解析器必须返回零地址。 解析 addr 记录的客户端必须检查零返回值，并将其视为一个未指定解析器的名称——即拒绝向该地址发送资金或与之交互。否则可能会导致用户不小心将资金发送到零地址。 更改地址必须触发以下事件: event AddrChanged(bytes32 indexed node, address a); 附录 A: 注册表的实现 contract ENS { struct Record { address owner; address resolver; uint64 ttl; } mapping(bytes32=>Record) records; event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner); event Transfer(bytes32 indexed node, address owner); event NewResolver(bytes32 indexed node, address resolver); modifier only_owner(bytes32 node) { if(records[node].owner != msg.sender) throw; _ } function ENS(address owner) { records[0].owner = owner; } function owner(bytes32 node) constant returns (address) { return records[node].owner; } function resolver(bytes32 node) constant returns (address) { return records[node].resolver; } function ttl(bytes32 node) constant returns (uint64) { return records[node].ttl; } function setOwner(bytes32 node, address owner) only_owner(node) { Transfer(node, owner); records[node].owner = owner; } function setSubnodeOwner(bytes32 node, bytes32 label, address owner) only_owner(node) { var subnode = sha3(node, label); NewOwner(node, label, owner); records[subnode].owner = owner; } function setResolver(bytes32 node, address resolver) only_owner(node) { NewResolver(node, resolver); records[node].resolver = resolver; } function setTTL(bytes32 node, uint64 ttl) only_owner(node) { NewTTL(node, ttl); records[node].ttl = ttl; } } 附录 B: 解析器的实现示例 内置解析器 最简单的解析器是通过实现合约地址配置来充当自己名称的解析器的合约: contract DoSomethingUseful { // Other code function addr(bytes32 node) constant returns (address) { return this; } function supportsInterface(bytes4 interfaceID) constant returns (bool) { return interfaceID == 0x3b3b57de || interfaceID == 0x01ffc9a7; } function() { throw; } } 这样的合约可以直接插入 ENS 注册表，在简单的用例中无需单独的解析器合约。但是，“抛出”未知函数调用的要求可能会干扰某些类型合约的正常运行。 独立解析器 一个实现合约地址配置的基本解析器，并且只允许其所有者更新记录: contract Resolver { event AddrChanged(bytes32 indexed node, address a); address owner; mapping(bytes32=>address) addresses; modifier only_owner() { if(msg.sender != owner) throw; _ } function Resolver() { owner = msg.sender; } function addr(bytes32 node) constant returns(address) { return addresses[node]; } function setAddr(bytes32 node, address addr) only_owner { addresses[node] = addr; AddrChanged(node, addr); } function supportsInterface(bytes4 interfaceID) constant returns (bool) { return interfaceID == 0x3b3b57de || interfaceID == 0x01ffc9a7; } function() { throw; } } 部署此合约后，通过更新某个名称在 ENS 注册表中的记录来引用此合约，然后使用同一节点（译注: 这里的同一节点可以理解为上述名称的所有者）调用 setAddr() 以设置它将解析到的合约地址。 公共解析器 与上面的解析器类似，此合约仅支持合约配置，但使用 ENS 注册来确定由谁负责更新记录条目: contract PublicResolver { event AddrChanged(bytes32 indexed node, address a); event ContentChanged(bytes32 indexed node, bytes32 hash); ENS ens; mapping(bytes32=>address) addresses; modifier only_owner(bytes32 node) { if(ens.owner(node) != msg.sender) throw; _ } function PublicResolver(address ensAddr) { ens = ENS(ensAddr); } function addr(bytes32 node) constant returns (address ret) { ret = addresses[node]; } function setAddr(bytes32 node, address addr) only_owner(node) { addresses[node] = addr; AddrChanged(node, addr); } function supportsInterface(bytes4 interfaceID) constant returns (bool) { return interfaceID == 0x3b3b57de || interfaceID == 0x01ffc9a7; } function() { throw; } } 附录 C: 注册器的实现示例 该注册器支持第一个请求某个名称的人免费注册该名称。 contract FIFSRegistrar { ENS ens; bytes32 rootNode; function FIFSRegistrar(address ensAddr, bytes32 node) { ens = ENS(ensAddr); rootNode = node; } function register(bytes32 subnode, address owner) { var node = sha3(rootNode, subnode); var currentOwner = ens.owner(node); if(currentOwner != 0 && currentOwner != msg.sender) throw; ens.setSubnodeOwner(rootNode, subnode, owner); } } © Pengfei Ni all right reserved，powered by GitbookUpdated at 2022-05-17 21:04:39 "},"docs/ens-improvement-proposals/ensip-2-initial-hash-registrar.html":{"url":"docs/ens-improvement-proposals/ensip-2-initial-hash-registrar.html","title":"ENSIP-2: 初始哈希注册器","summary":"Describes the hash registrar initially used to register ENS .eth domains (formerly EIP-162).","keywords":"","body":" 作者 Maurelian, Nick Johnson, Alex Van de Sande 状态 废止 创建日期 2016-10-25 Abstract This ERC describes the implementation, as deployed to the main ethereum network on 2017-05-04, of a registrar contract to govern the allocation of names in the Ethereum Name Service (ENS). The corresponding source code is here. For more background, refer to ENSIP-1. Registrars are responsible for allocating domain names to users of the system, and are the only entities capable of updating the ENS; the owner of a node in the ENS registry is its registrar. Registrars may be contracts or externally owned accounts, though it is expected that the root and top-level registrars, at a minimum, will be implemented as contracts. - ENSIP-1 A well designed and governed registrar is essential to the success of the ENS described in ENSIP-1, but is described separately in this document as it is external to the core ENS protocol. In order to maximize utility and adoption of a new namespace, the registrar should mitigate speculation and \"name squatting\", however the best approach for mitigation is unclear. Thus an \"initial\" registrar is proposed, which implements a simple approach to name allocation. During the initial period, the available namespace will be significantly restricted to the .eth top level domain, and subdomain shorter than 7 characters in length disallowed. This specification largely describes @alexvandesande and @arachnid's hash registrar implementation in order to facilitate discussion. The intent is to replace the Initial Registrar contract with a permanent registrar contract. The Permanent Registrar will increase the available namespace, and incorporate lessons learned from the performance of the Initial Registrar. This upgrade is expected to take place within approximately 2 years of initial deployment. Motivations The following factors should be considered in order to optimize for adoption of the ENS, and good governance of the Initial Registrar's namespace. Upgradability: The Initial Registrar should be safely upgradeable, so that knowledge gained during its deployment can be used to replace it with an improved and permanent registrar. Effective allocation: Newly released namespaces often create a land grab situation, resulting in many potentially valuable names being purchased but unused, with the hope of re-selling at a profit. This reduces the availability of the most useful names, in turn decreasing the utility of the name service to end users. Achieving an effective allocation may or may not require human intervention for dispute resolution and other forms of curation. The Initial Registrar should not aim to create to most effective possible allocation, but instead limit the cost of misallocation in the long term. Security: The registrar will hold a balance of ether without an explicit limit. It must be designed securely. Simplicity: The ENS specification itself emphasizes a separation of concerns, allowing the most essential element, the registry to be as simple as possible. The interim registrar in turn should be as simple as possible while still meeting its other design goals. Adoption: Successful standards become more successful due to network effects. The registrar should consider what strategies will encourage the adoption of the ENS in general, and the namespace it controls in particular. Specification Initial restrictions The Initial Registrar is expected to be in service for approximately two years, prior to upgrading. This should be sufficient time to learn, observe, and design an updated system. During the initial two year period, the available name space will be restricted to the .eth TLD. This restriction is enforced by the owner of the ENS root node who should not assign any nodes other than .eth to the Initial Registrar. The ENS's root node should be controlled by multiple parties using a multisig contract. The Initial Registrar will also prohibit registration of names 6 characters or less in length. Name format for hash registration Names submitted to the initial registrar must be hashed using Ethereum's sha3 function. Note that the hashes submitted to the registrar are the hash of the subdomain label being registered, not the namehash as defined in ENSIP-1. For example, in order to register abcdefg.eth, one should submit sha3('abcdefg'), not sha3(sha3(0, 'eth'), 'abcdefg'). Auctioning names The registrar will allocate the available names through a Vickrey auction: A Vickrey auction is a type of sealed-bid auction. Bidders submit written bids without knowing the bid of the other people in the auction. The highest bidder wins but the price paid is the second-highest bid. This type of auction... gives bidders an incentive to bid their true value. - Vickrey Auction, Wikipedia The auction lifecycle of a name has 5 possible states, or Modes. Not-yet-available: The majority of names will be initially unavailable for auction, and will become available some time during the 8 weeks after launch. Open: The earliest availability for a name is determined by the most significant byte of its sha3 hash. 0x00 would become available immediately, 0xFF would become available after 8 weeks, and the availability of other names is distributed accordingly. Once a name is available, it is possible to start an auction on it. Auction: Once the auction for a name has begun, there is a 72 hour bidding period. Bidders must submit a payment of ether, along with sealed bids as a hash of sha3(bytes32 hash, address owner, uint value, bytes32 salt). The bidder may obfuscate the true bid value by sending a greater amount of ether. Reveal: After the bidding period, a 48 hour reveal period commences. During this time, bidders must reveal the true parameters of their sealed bid. As bids are revealed, ether payments are returned according to the schedule of \"refund ratios\" outlined in the table below. If no bids are revealed, the name will return to the Open state. Owned: After the reveal period has finished, the winning bidder must submit a transaction to finalize the auction, which then calls the ENS's setSubnodeOwner function, recording the winning bidder's address as the owner of the hash of the name. The following table outlines important parameters which define the Registrar's auction mechanism. Registrar Parameters Name Description Value totalAuctionLength The full time period from start of auction to end of the reveal period. 5 days revealPeriod The length of the time period during which bidding is no longer allowed, and bids must be revealed. 48 hours launchLength The time period during which all names will become available for auction. 8 weeks minPrice The minimum amount of ether which must be locked up in exchange for ownership of a name. 0.01 ether Deeds The Initial Registrar contract does not hold a balance itself. All ether sent to the Registrar will be held in a separate Deed contracts. A deed contract is first created and funded when a sealed bid is submitted. After an auction is completed and a hash is registered, the deed for the winning bid is held in exchange for ownership of the hash. Non-winning bids are refunded. A deed for an owned name may be transferred to another account by its owner, thus transferring ownership and control of the name. After 1 year of registration, the owner of a hash may choose to relinquish ownership and have the value of the deed returned to them. Deeds for non-winning bids can be closed by various methods, at which time any ether held will either be returned to the bidder, burnt, or sent to someone else as a reward for actions which help the registrar. The following table outlines what portion of the balance held in a deed contract will be returned upon closure, and to whom. The remaining balance will be burnt. Refund schedule Reason for Deed closure Refund Recipient Refund Percentage A valid non-winning bid is revealed. Bidder 99.5% A bid submitted after the auction period is revealed. Bidder 99.5% An otherwise valid bid is revealed on an owned name. 1 Bidder 0.5% An expired sealed bid is cancelled. 2 Canceler 0.5% A registered hash is reported as invalid. 3 Reporter 50% A registered hash is reported as invalid. 3 Owner 50% Notes: This incentivizes all bids to be revealed in time. If bids could be revealed late, an extortion attack on the current highest bidder could be made by threatening to reveal a new second highest bid. A bid which remains sealed after more than 2 weeks and 5 days may be cancelled by anyone to collect a small reward. Since names are hashed before auctioning and registration, the Initial Registrar is unable to enforce character length restrictions independently. A reward is therefore provided for reporting invalid names. Deployment and Upgrade process The Initial Registrar requires the ENS's address as a constructor, and should be deployed after the ENS. The multisig account owning the root node in the ENS should then set the Initial Registrar's address as owner of the eth node. The Initial Registrar is expected to be replaced by a Permanent Registrar approximately 2 years after deployment. The following process should be used for the upgrade: The Permanent Registrar contract will be deployed. The multisig account owning the root node in the ENS will assign ownership of the .eth node to the Permanent Registrar. Owners of hashes in the Initial Registrar will be responsible for registering their deeds to the Permanent Registrar. A couple options are considered here: Require owners to transfer their ownership prior to a cutoff date in order to maintain ownership and/or continue name resolution services. Have the Permanent Registrar query the Initial Registrar for ownership if it is lacking an entry. Planned deactivation In order to limit dependence on the Initial Registrar, new auctions will stop after 4 years, and all ether held in deeds after 8 years will become unreachable. Registrar Interface function state(bytes32 _hash) constant returns (Mode) Implements a state machine returning the current state of a name function entries(bytes32 _hash) constant returns (Mode, address, uint, uint, uint) Returns the following information regarding a registered name: state deed address registration date balance of the deed highest value bid at auction function getAllowedTime(bytes32 _hash) constant returns (uint timestamp) Returns the time at which the hash will no longer be in the initial not-yet-available state. function isAllowed(bytes32 _hash, uint _timestamp) constant returns (bool allowed) Takes a hash and a time, returns true if and only if it has passed the initial not-yet-available state. function startAuction(bytes32 _hash); Moves the state of a hash from Open to Auction. Throws if state is not Open. function startAuctions(bytes32[] _hashes); Starts multiple auctions on an array of hashes. This enables someone to open up an auction for a number of dummy hashes when they are only really interested in bidding for one. This will increase the cost for an attacker to simply bid blindly on all new auctions. Dummy auctions that are open but not bid on are closed after a week. function shaBid(bytes32 hash, address owner, uint value, bytes32 salt) constant returns (bytes32 sealedBid); Takes the parameters of a bid, and returns the sealedBid hash value required to participate in the bidding for an auction. This obfuscates the parameters in order to mimic the mechanics of placing a bid in an envelope. function newBid(bytes32 sealedBid); Bids are sent by sending a message to the main contract with a sealedBid hash and an amount of ether. The hash contains information about the bid, including the bidded name hash, the bid value, and a random salt. Bids are not tied to any one auction until they are revealed. The value of the bid itself can be masqueraded by sending more than the value of your actual bid. This is followed by a 48h reveal period. Bids revealed after this period will be burned and the ether unrecoverable. Since this is an auction, it is expected that most public hashes, like known domains and common dictionary words, will have multiple bidders pushing the price up. function startAuctionsAndBid(bytes32[] hashes, bytes32 sealedBid) A utility function allowing a call to startAuctions followed by newBid in a single transaction. function unsealBid(bytes32 _hash, address _owner, uint _value, bytes32 _salt); Once the bidding period is completed, there is a reveal period during with the properties of a bid are submitted to reveal them. The registrar hashes these properties using the shaBid() function above to verify that they match a pre-existing sealed bid. If the unsealedBid is the new best bid, the old best bid is returned to its bidder. function cancelBid(bytes32 seal); Cancels an unrevealed bid according to the rules described in the notes on the refund schedule above. function finalizeAuction(bytes32 _hash); After the registration date has passed, this function can be called to finalize the auction, which then calls the ENS function setSubnodeOwner() updating the ENS record to set the winning bidder as owner of the node. function transfer(bytes32 _hash, address newOwner); Update the owner of the ENS node corresponding to the submitted hash to a new owner. This function must be callable only by the current owner. function releaseDeed(bytes32 _hash); After some time, the owner can release the property and get their ether back. function invalidateName(string unhashedName); Since registration is done on the hash of a name, the registrar itself cannot validate names. This function can be used to report a name which is 6 characters long or less. If it has been registered, the submitter will earn 10% of the deed value. We are purposefully handicapping the simplified registrar as a way to force it into being restructured in a few years. function eraseNode(bytes32[] labels) Allows anyone to delete the owner and resolver records for a subdomain of a name that is not currently owned in the registrar. For instance, to zero foo.bar.eth on a registrar that owns .eth, pass an array containing [sha3('foo'), sha3('bar')]. function transferRegistrars(bytes32 _hash) onlyOwner(_hash); Used during the upgrade process to a permanent registrar. If this registrar is no longer the owner of the its root node in the ENS, this function will transfers the deed to the current owner, which should be a new registrar. This function throws if this registrar still owns its root node. Rationale Starting with a temporary registrar Anticipating and designing for all the potential issues of name allocation names is unlikely to succeed. This approach chooses not to be concerned with getting it perfect, but allows us to observe and learn with training wheels on, and implement improvements before expanding the available namespace to shorter names or another TLD. Valid names >= 7 characters Preserving the shortest, and often most valuable, domain names for the upgraded registrar provides the opportunity to implement processes for dispute resolution (assuming they are found to be necessary). Delayed release of names A slower release allows for extra time to identify, and address any issues which may arise after launch. Restricting TLD to .eth Choosing a single TLD helps to maximize network effects by focusing on one namespace. A three letter TLD is a pattern made familiar by it's common usage in internet domain names. This familiarity significantly increases the potential of the ENS to be integrated into pre-existing DNS systems, and reserved as a special-use domain name. A recent precedent for this is the reservation of the .onion domain. Holding ether as collateral This approach is simpler than the familiar model of requiring owners to make recurring payments to retain ownership of a domain name. It also makes the initial registrar a revenue neutral service. Prior work This document borrows heavily from several sources: ENSIP-1 outlines the initial implementation of the Registry Contract (ENS.sol) and associated Resolver contracts. ERC-26 was the first ERC to propose a name service at the contract layer @alexvandesande's current implementation of the HashRegistrar Edits: 2016-10-26 Added link Alex's design in abstract 2016-11-01 change 'Planned deactivation' to h3' 2017-03-13 Update timelines for bidding and reveal periods Copyright Copyright and related rights waived via CC0. © Pengfei Ni all right reserved，powered by GitbookUpdated at 2022-05-17 21:04:39 "},"docs/ens-improvement-proposals/ensip-3-reverse-resolution.html":{"url":"docs/ens-improvement-proposals/ensip-3-reverse-resolution.html","title":"ENSIP-3: 反向解析","summary":"Specifies a TLD, registrar, and resolver interface for reverse resolution of Ethereum addresses using ENS (formerly EIP-181).","keywords":"","body":" 作者 Nick Johnson \\nick@ens.domains 状态 完结 提交时间 2016-12-01 摘要 这个 ENSIP 为 ENS 的反向解析指定 TLD、注册器和解析器接口。它支持将人类可读的名称与任何以太坊区块链地址关联起来。解析器可以确定反向记录是由相关以太坊地址的所有者提交的。 动机 虽然名称服务主要用于正向解析——从人类可读的标识符解析到机器可读的标识符——但在许多情况下，反向解析也很有用: 在某些应用程序中，用户需要关注自己的账户，那么在应用程序中显示名称会比显示地址更合理，即便这个名称最初是通过地址添加的。 通过将元数据（比如描述信息等）关联到一个地址来允许信息读取，而不必关心最初如何找到这个地址。 人们不需要取得某个地址的所有权，就可以将名称解析到这个地址。反向记录允许地址的所有者声明一个名称作为该地址的专用名称。 规范 反向 ENS 记录与正向记录以相同的方式存储在 ENS 层次结构中，在保留域 addr.reverse 之下。要为给定帐户的反向记录生成 ENS 名称，请将帐户转换为小写的十六进制表示，并附加 addr.reverse。例如，ENS 注册表地址 \"0x112234455c3a32fd11230c42e7bccd4a84e02010\" 有反向记录存储在 112234455c3a32fd11230c42e7bccd4a84e02010.addr.reverse。 请注意，这意味着想要对地址进行动态反向解析的合约需要在合约中执行十六进制编码。 注册器 addr.reverse 域的所有者是一个注册器，它允许调用者为自己的地址取得反向记录的所有权。提供如下方法: function claim(address owner) returns (bytes32 node) 当被账户 x 调用时，会通知 ENS 注册表将 hex(x) + '.addr.reverse' 的所有权转移至给定的地址，并返回本次转移的 ENS 记录的 namehash。 允许调用者为相关节点指定除自己以外的所有者，这有助于需要精确反向 ENS 记录的合约，并在构造函数中以最少的代码将此委托给合约的创建者。 reverseRegistrar.claim(msg.sender) function claimWithResolver(address owner, address resolver) returns (bytes32 node) 当被账户 x 调用时，通知 ENS 注册表为 hex(x) + '.addr.reverse' 设置指定的解析器，然后将名称的所有权转移到提供的地址，并返回本次转移的 ENS 记录的 namehash。这个方法便于设置一个自定义的解析器和所有者，同时要比直接调用 claim 需要更少的交易次数。 function setName(string name) returns (bytes32 node) 当被账户 x 调用时，为 hex(x) + '.addr.reverse' 这一名设置一个默认解析器，并将名称记录设置为指定名称。这个方法便于用户在单个交易中完成反向记录设置。 解析器接口 定义了一个新的解析器接口，由以下方法组成: function name(bytes32 node) constant returns (string); 实现此接口的解析器必须为请求的节点返回一个有效的 ENS 名称，如果没有为请求的节点定义名称，则返回空字符串。 该接口的 ID 为 0x691f3431。 未来的 ENSIP 可能会指定晚多适合反向 ENS 记录的类型。 附录 1: 注册器的实现 这个注册器是用 Solidity 编写的，实现了上文描述的规范。 pragma solidity ^0.4.10; import \"./AbstractENS.sol\"; contract Resolver { function setName(bytes32 node, string name) public; } /** * @dev Provides a default implementation of a resolver for reverse records, * which permits only the owner to update it. */ contract DefaultReverseResolver is Resolver { AbstractENS public ens; mapping(bytes32=>string) public name; /** * @dev Constructor * @param ensAddr The address of the ENS registry. */ function DefaultReverseResolver(AbstractENS ensAddr) { ens = ensAddr; } /** * @dev Only permits calls by the reverse registrar. * @param node The node permission is required for. */ modifier owner_only(bytes32 node) { require(msg.sender == ens.owner(node)); _; } /** * @dev Sets the name for a node. * @param node The node to update. * @param _name The name to set. */ function setName(bytes32 node, string _name) public owner_only(node) { name[node] = _name; } } contract ReverseRegistrar { // namehash('addr.reverse') bytes32 constant ADDR_REVERSE_NODE = 0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2; AbstractENS public ens; Resolver public defaultResolver; /** * @dev Constructor * @param ensAddr The address of the ENS registry. * @param resolverAddr The address of the default reverse resolver. */ function ReverseRegistrar(AbstractENS ensAddr, Resolver resolverAddr) { ens = ensAddr; defaultResolver = resolverAddr; } /** * @dev Transfers ownership of the reverse ENS record associated with the * calling account. * @param owner The address to set as the owner of the reverse record in ENS. * @return The ENS node hash of the reverse record. */ function claim(address owner) returns (bytes32 node) { return claimWithResolver(owner, 0); } /** * @dev Transfers ownership of the reverse ENS record associated with the * calling account. * @param owner The address to set as the owner of the reverse record in ENS. * @param resolver The address of the resolver to set; 0 to leave unchanged. * @return The ENS node hash of the reverse record. */ function claimWithResolver(address owner, address resolver) returns (bytes32 node) { var label = sha3HexAddress(msg.sender); node = sha3(ADDR_REVERSE_NODE, label); var currentOwner = ens.owner(node); // Update the resolver if required if(resolver != 0 && resolver != ens.resolver(node)) { // Transfer the name to us first if it's not already if(currentOwner != address(this)) { ens.setSubnodeOwner(ADDR_REVERSE_NODE, label, this); currentOwner = address(this); } ens.setResolver(node, resolver); } // Update the owner if required if(currentOwner != owner) { ens.setSubnodeOwner(ADDR_REVERSE_NODE, label, owner); } return node; } /** * @dev Sets the `name()` record for the reverse ENS record associated with * the calling account. First updates the resolver to the default reverse * resolver if necessary. * @param name The name to set for this address. * @return The ENS node hash of the reverse record. */ function setName(string name) returns (bytes32 node) { node = claimWithResolver(this, defaultResolver); defaultResolver.setName(node, name); return node; } /** * @dev Returns the node hash for a given account's reverse records. * @param addr The address to hash * @return The ENS node hash. */ function node(address addr) constant returns (bytes32 ret) { return sha3(ADDR_REVERSE_NODE, sha3HexAddress(addr)); } /** * @dev An optimised function to compute the sha3 of the lower-case * hexadecimal representation of an Ethereum address. * @param addr The address to hash * @return The SHA3 hash of the lower-case hexadecimal encoding of the * input address. */ function sha3HexAddress(address addr) private returns (bytes32 ret) { addr; ret; // Stop warning us about unused variables assembly { let lookup := 0x3031323334353637383961626364656600000000000000000000000000000000 let i := 40 loop: i := sub(i, 1) mstore8(i, byte(and(addr, 0xf), lookup)) addr := div(addr, 0x10) i := sub(i, 1) mstore8(i, byte(and(addr, 0xf), lookup)) addr := div(addr, 0x10) jumpi(loop, i) ret := sha3(0, 40) } } } 版权 通过 CC0 放弃版权及相关权利。 © Pengfei Ni all right reserved，powered by GitbookUpdated at 2022-05-17 21:04:39 "},"docs/ens-improvement-proposals/ensip-4-support-for-contract-abis.html":{"url":"docs/ens-improvement-proposals/ensip-4-support-for-contract-abis.html","title":"ENSIP-4: 合约 ABI 支持","summary":"A mechanism for storing ABI definitions in ENS, for easy lookup of contract interfaces by callers (formerly EIP-205).","keywords":"","body":" 作者 Nick Johnson \\nick@ens.domains 状态 完结 提交时间 2017-02-06 摘要 ABI 是与大多数合约交互所需的重要元数据。目前，它们通常是在带外提供的，这给与合约交互增加了额外的负担，特别是在一次性的基础上，或者 ABI 可能会随着时间的推移而更新。由于 ABI 的体积较小，因此可以采用另一种解决方案，即将其存储在 ENS 中，然后通过相同的过程进行名称查找和 ABI 发现。 ABI 通常是非常紧凑。对于 DAO，我们能够找到的在用的最大 ABI，是 9450 字节的未压缩 JSON、6920 字节的未压缩 CBOR，以及使用 zlib 压缩 JSON 表单后的1128字节。通过使用允许消除重复字符串的 CBOR 扩展，可以在 CBOR 编码上获得进一步的增益，这在 ABI 中被广泛采用。然而，大多数 ABI 都比这个短得多，只包含几百个字节的未压缩 JSON。 这个 ENSIP 定义了一个解析器配置文件，用于检索合约 ABI，以及为不同应用程序存储 ABI 的编码标准，允许用户根据他们对紧凑性的需求和其他因素 (如链上访问) 在不同的表示之间进行选择。 规范 ABI 编码 为了在链上体积和可访问性之间实现不同的权衡，定义了几种 ABI 编码。每种 ABI 编码由一个唯一的常数定义，它只有一个位集，允许在一个单位中指定 256 个唯一的编码。 目前承认的编码有: ID 描述 1 JSON 2 zlib-compressed JSON 4 CBOR 8 URI 这个表将来可能会通过 ENSIP 程序进行扩展。 编码类型 1 表示明文 JSON，未压缩。这是 ABI 通常编码的标准格式，但也是最庞大的，不容易在链上解析。 编码类型 2 表示 zlib 压缩的 JSON。这比未压缩的 JSON 要小得多，而且可以直接从链下解码。然而，对于链上用户来说，这是不现实的。 编码类型 4 表示 CBOR。CBOR 是一种二进制编码格式，是 JSON 的超集，在 EVM 等有限的环境中更紧凑，也更容易解析。强烈鼓励支持 CBOR 的用户也支持对 CBOR 的 stringref 扩展，这大大减少了编码大小。 编码类型 8 表示可以通过指定的 URI 找到 ABI。这通常是受支持的表单中最紧凑的，但也为实现者增加了外部依赖。指定的 URI 可以使用任何模式，但 HTTP、IPFS 和 Swarm 应该是最常见的模式。 解析器配置 定义了一个新的解析器接口，由以下方法组成: function ABI(bytes32 node, uint256 contentType) constant returns (uint256, bytes); 该接口的接口 ID 为 0x2203ab56。 contentType 是一个位域，是调用者将接受的所有编码类型的位或。实现此接口的解析器必须返回使用所请求格式之一编码的 ABI；如果它们没有此函数的 ABI，或者不支持任何所请求的格式，则返回 (0, \"\")。 abi 解析器配置对于正向和反向解析都有效。 ABI 查询过程 当试图根据 ENS 名称获取 ABI 时，实现者应该首先尝试对名称本身进行 ABI 查找。如果查找没有返回结果，他们应该尝试对该名称解析到的以太坊地址进行反向查找。 实现者应该支持尽可能多的 ABI 编码格式。 原理 在链上存储 ABI 使得希望获取它们的应用程序不必再引入额外依赖项，比如 Swarm 或 HTTP 访问。考虑到 ABI 的典型压缩性，我们认为在许多情况下这是一个有价值的折衷。 两步解析过程允许不同的名称为相同的合约提供不同的 ABI，例如，向一些调用者提供最小的 ABI 很有用，以及为没有指定自己的合约指定 ABI。在反向记录上查找 ABI 的方法允许合约指定它们自己的规范 ABI，并防止在多个名称引用同一个合约而不需要使用不同的 ABI 时出现重复。 版权 通过 CC0 放弃版权及相关权利。 © Pengfei Ni all right reserved，powered by GitbookUpdated at 2022-05-17 21:04:39 "},"docs/ens-improvement-proposals/ensip-5-text-records.html":{"url":"docs/ens-improvement-proposals/ensip-5-text-records.html","title":"ENSIP-5: 文本记录","summary":"A standard for storage of text records in ENS (formerly EIP-634).","keywords":"","body":" 作者 Richard Moore (@ricmoo) 状态 完结 提交时间 2017-05-17 摘要 这个 ENSIP 为 ENS 定义了一个解析器记录类型，它允许查找任意键值的文本数据，能够支持 ENS 名称持有人将电子邮件地址、URL 和其他信息数据与 ENS 名称关联起来。 动机 人们常常希望将人类可读的元数据与机器驱动的数据相关联，用于调试信息、维护信息、报告信息和一般信息。 在这个 ENSIP 中，我们为 ENS 定义了一个简单的解析器记录类型，它允许 ENS 名称与任意键值文本相关联。 规范 解析器配置 定义了一个新的解析器接口，该接口由以下方法组成: interface IERC634 { /// @notice Returns the text data associated with a key for an ENS name /// @param node A nodehash for an ENS name /// @param key A key to lookup text data for /// @return The text data function text(bytes32 node, string key) view returns (string text); } 它在 EIP-165 标准下的接口 ID 是 0x59d1d43c. text 数据可以是任意 UTF-8 字符串。如果该键不存在，则必须返回空字符串。 通用键 通用键必须由小写字母、数字和连字符 (-) 组成。 avatar - 用作头像或 logo 的图像的 URL description - 这个名称的描述信息 display - ENS 名称的一个规范化展示，当它的大小写被折叠时，必须匹配 ENS 的名称，如果不匹配，客户端应该忽略这个值 (例如: \"ricmoo.eth\" 可以将此条目设置为 \"RicMoo.eth\") email - 电子邮箱地址 keywords - 用逗号分隔的关键字列表，按照重要性排序；使用这个内容的客户端可以选择一个阈值，从而可以忽略超过这个阈值的关键词 mail - 现实中的邮寄地址 notice - 与这个名称有关的通知 location - 所在位置 (例如 \"Toronto, Canada\") phone - E.164 字符串形式的电话号码 url - 网站的 URL 服务键 服务键必须由这项服务拥有的命名空间按照反向点标记法组成，例如，DNS 域名 (.com 和 .io等) 或 ENS 名称 (即 .eth)。服务键必须至少包含一个点。 这可以让新服务使用它们自己的键，而不必担心与现有服务发生冲突，也意味着新服务不需要更新此文档。 以下这些服务比较常见，所以在这里专门提出建议，但理想情况下，服务应该声明自己的键。 com.github - GitHub 用户名 com.peepeth - Peepeth 用户名 com.linkedin - LinkedIn 用户名 com.twitter - Twitter 用户名 io.keybase - Keybase 用户名 org.telegram - Telegram 用户名 服务所有者还可以为他们的键指定一个层次结构，例如: com.example.users com.example.groups com.example.groups.public com.example.groups.private 遗留键 以下键在此 ENSIP 的早期版本中指定。 它们的使用可能不会很广泛，但是如果上述替换键失败，尝试最大兼容性的应用程序有可能希望查询这些键作为后备。 vnd.github - GitHub 用户名 (已更新为 com.github) vnd.peepeth - peepeth 用户名 (已更新为 com.peepeth) vnd.twitter - twitter 用户名 (已更新为 com.twitter) 原理 应用程序专用记录类型 vs 通用记录类型 我们没有定义大量的专用记录类型 (全部都是人类可读的数据)，而是参照 DNS 的 TXT 记录的修正模式，该模式支持通用的键值对，将来无需调整解析器也能够进行扩展，同时支持应用程序根据自己的需求使用自定义键。 而不是定义大量的特定记录类型等一般人类可读的数据)(每个“url”和“电子邮件”,我们遵循一个适应模型DNS的“三种”记录,允许一个通用键和值,使未来的扩展没有调整解析器,同时允许应用程序使用自定义键达到自己的目的。 向后兼容 不适用。 安全注意事项 无 版权 通过 CC0 放弃版权及相关权利。 © Pengfei Ni all right reserved，powered by GitbookUpdated at 2022-05-17 21:04:39 "},"docs/ens-improvement-proposals/ensip-6-dns-in-ens.html":{"url":"docs/ens-improvement-proposals/ensip-6-dns-in-ens.html","title":"ENSIP-6: ENS 中的 DNS","summary":"为 ENS 定义了一个解析类型，提供 DNS 记录的存储和查找功能 (原来的 EIP-1185)。","keywords":"","body":"这个标准已经过时了，并且不能反映当前的实现。 作者 Jim McDonald (@mcdee) 状态 停止 创建时间 2018-06-26 Abstract This ENSIP defines a resolver profile for ENS that provides features for storage and lookup of DNS records. This allows ENS to be used as a store of authoritative DNS information. Motivation ENS is a highly desirable store for DNS information. It provides the distributed authority of DNS without conflating ownership and authoritative serving of information. With ENS, the owner of a domain has full control over their own DNS records. Also, ENS has the ability (through smart contracts) for a domain's subdomains to be irrevocably assigned to another entity. Specification The resolver profile to support DNS on ENS follows the resolver specification as defined in #137. Traditionally, DNS is a zone-based system in that all of the records for a zone are kept together in the same file. This has the benefit of simplicity and atomicity of zone updates, but when transposed to ENS can result in significant gas costs for simple changes. As a result, the resolver works on the basis of record sets. A record set is uniquely defined by the tuple (domain, name, resource record type), for example the tuple (example.com, www.example.com, A) defines the record set of A records for the name www.example.com in the domain example.com. A record set can contain 0 or more values, for example if www.example.com has A records 1.2.3.4 and 5.6.7.8 then the aforementioned tuple will have two values. The choice to work at the level of record sets rather than zones means that this specification cannot completely support some features of DNS, such as zone transfers and DNSSEC. It would be possible to build a different resolver profile that works at the zone level, however it would be very expensive to carry out updates and so is not considered further for this ENSIP. The DNS resolver interface consists of two functions to set DNS information and two functions to query DNS information. setDNSRecords(bytes32 node, bytes data) setDNSRecords() sets, updates or clears 1 or more DNS records for a given node. It has function signature 0x0af179d7. The arguments for the function are as follows: node: the namehash of the fully-qualified domain in ENS for which to set the records. Namehashes are defined in #137 data: 1 or more DNS records in DNS wire format. Any record that is supplied without a value will be cleared. Note that all records in the same RRset should be contiguous within the data; if not then the later RRsets will overwrite the earlier one(s) clearDNSZone(bytes32 node) clearDNSZone() removes all DNS records for the domain. It has function signature 0xad5780af. Although it is possible to clear records individually with setDNSRecords() as described above this requires the owner to know all of the records that have been set (as the resolver has no methods to iterate over the records for a given domain), and might require multiple transactions. clearDNSZone() removes all zone information in a single operation. The arguments for the function is as follows: node: the namehash of the fully-qualified domain in ENS for which to clear the records. Namehashes are defined in #137 dnsRecords(bytes32 node, bytes32 name, uint16 resource) view returns (bytes) dnsRecords() obtains the DNS records for a given node, name and resource. It has function signature 0x2461e851. The arguments for the function are as follows: node: the namehash of the fully-qualified domain in ENS for which to set the records. Namehashes are defined in #137 name: the keccak256() hash of the name of the record in DNS wire format. resource: the resource record ID. Resource record IDs are defined in https://en.wikipedia.org/wiki/List\\_of\\_DNS\\_record\\_types The function returns all matching records in DNS wire format. If there are no records present the function will return nothing. hasDNSRecords(bytes32 node, bytes32 name) view returns (bool) hasDNSRecords() reports if there are any records for the provided name in the domain. It has function signature 0x4cbf6ba4. This function is needed by DNS resolvers when working with wildcard resources as defined in https://tools.ietf.org/html/rfc4592 The arguments for the function are as follows: node: the namehash of the fully-qualified domain in ENS for which to set the records. Namehashes are defined in #137 name: the keccak256() hash of the name of the record in DNS wire format. The function returns true if there are any records for the provided node and name, otherwise false. Backwards compatibility Not applicable. Implementation The reference implementation of the DNS resolver is at https://github.com/wealdtech/wealdtech-solidity/blob/master/contracts/ens/DNSResolver.sol https://github.com/wealdtech/ethereal.git can be used to test the functionality of the resolver with the \"dns set\", \"dns get\" and \"dns clear\" commands. Test Cases Test cases for the DNS resolver are at https://github.com/wealdtech/wealdtech-solidity/blob/master/test/ens/DNSResolver.js Copyright Copyright and related rights waived via CC0. © Pengfei Ni all right reserved，powered by GitbookUpdated at 2022-05-17 21:05:15 "},"docs/ens-improvement-proposals/ensip-7-contenthash-field.html":{"url":"docs/ens-improvement-proposals/ensip-7-contenthash-field.html","title":"ENSIP-7: 内容哈希字段","summary":"引入一个字段，用于在 ENS (原来的 EIP-1577) 中存储内容地址和哈希值。","keywords":"","body":" 作者 Dean Eigenmann [dean@ens.domains](mailto:dean@ens.domains), Nick Johnson [nick@ens.domains](mailto:nick@ens.domains) 状态 完结 创建时间 2018-11-13 摘要 这个 ENSIP 为 ENS 解析器引入了新的 contenthash 字段，允许更好地定义名称到网络和内容地址的映射系统。此外， content 和 multihash 字段已弃用。 动机 多个应用程序，包括 Metamask 和一些类似 Status 的移动客户端，已经开始将 ENS 名称解析到托管在分布式系统上的内容，例如 IPFS 和 Swarm。由于存储和寻址内容的方式多种多样，因此需要一种标准，以便这些应用程序知道如何解析名称，并让名称所有者知道如何解析其内容。 contenthash 字段可以方便地规范 ENS 中的网络和内容地址。 规范 The field contenthash is introduced, which permits a wide range of protocols to be supported by ENS names. Resolvers supporting this field MUST return true when the supportsInterface function is called with argument 0xbc1c58d1. 引入了字段 contenthash，它允许 ENS 名称支持广泛的协议。当使用参数 0xbc1c58d1 调用 supportsInterface 函数时，支持该字段的解析器必须返回 true。 字段 content 和 multihash 已弃用。 contenthash 返回的值必须表示为机器可读的 multicodec。该格式标准如下: multiformats/multicodec 仓库中定义了 protoCodes 及其含义。 该值的编码取决于 protoCode 指定的内容类型。编码为 0xe3 和 0xe4 的值表示 IPFS 和 Swarm 内容，这些值被编码为 v1 CIDs，没有基前缀，这意味着它们的值被格式化如下: 当解析 contenthash 时，应用程序必须使用协议代码来确定被编码的地址类型，并在支持的情况下为该协议解析正确的地址。 示例 IPFS 输入数据: storage system: IPFS (0xe3) CID version: 1 (0x01) content type: dag-pb (0x70) hash function: sha2-256 (0x12) hash length: 32 bytes (0x20) hash: 29f2d17be6139079dc48696d1f582a8530eb9805b561eda517e22a892c7e3f1f 二进制格式: 0xe3010170122029f2d17be6139079dc48696d1f582a8530eb9805b561eda517e22a892c7e3f1f 文本格式: ipfs://QmRAQB6YaCyidP37UdDnjFY5vQuiBrcqdyoW1CuDgwxkD4 Swarm 输入数据: storage system: Swarm (0xe4) CID version: 1 (0x01) content type: swarm-manifest (0xfa) hash function: keccak256 (0x1b) hash length: 32 bytes (0x20) hash: d1de9994b4d039f6548d191eb26786769f580809256b4685ef316805265ea162 二进制格式: 0xe40101fa011b20d1de9994b4d039f6548d191eb26786769f580809256b4685ef316805265ea162 文本格式: bzz://d1de9994b4d039f6548d191eb26786769f580809256b4685ef316805265ea162 使用 swarm 哈希的示例: $ swarm hash ens contenthash d1de9994b4d039f6548d191eb26786769f580809256b4685ef316805265ea162 > e40101fa011b20d1de9994b4d039f6548d191eb26786769f580809256b4685ef316805265ea162 回退 为了支持那些将 IPFS 或 Swarm hash 存储在 content 字段中的名称，必须设立一个宽限期，为那些名称的持有人提供时间来更新他们的名称。如果一个解析器不支持 multihash 接口，它必须检查是否支持 content 接口。如果支持，则该字段的值应以上下文相关的方式处理并解析。该状态必须保持到 2019 年 3 月 31日。 实现 为了支持 contenthash，已经开发了一个新的解析器，可以在 这里 找到，你也可以在下面找到这个智能合约: 主网 : 0xd3ddccdd3b25a8a7423b5bee360a42146eb4baf3 Ropsten : 0xde469c7106a9fbc3fb98912bb00be983a89bddca 编码和解码 contenthash 已经通过多种语言来实现: JavaScript Python 版权 通过 CC0 放弃版权及相关权利。 © Pengfei Ni all right reserved，powered by GitbookUpdated at 2022-05-17 21:04:39 "},"docs/ens-improvement-proposals/ensip-8-interface-discovery.html":{"url":"docs/ens-improvement-proposals/ensip-8-interface-discovery.html","title":"ENSIP-8: 接口发现","summary":"定义一种将合约接口与 ENS 名称和地址关联起来的方法，以及发现这些接口的方法 (原来的 EIP-1844)。","keywords":"","body":" 作者 Nick Johnson \\nick@ens.domains 状态 完结 提交时间 2019-03-05 摘要 这个 ENSIP 指定了一种方法，用于公开与 ENS 名称或地址 (通常是合约地址) 相关联的接口，还允许应用程序发现这些接口并与之交互。接口既可以由目标合约 (如果有的话) 实现，也可以由任何其他合约实现。 动机 EIP-165 支持接口发现——确定给定地址的合约是否支持所请求的接口。然而，在许多情况下，能够发现与其他合约实现的名称或地址相关联的功能是很有用的。 例如，代币合约本身可能不提供任何类型的“原子交换”功能，但可能有相关的合约提供。通过 ENS 接口发现，代币合约可以公开该元数据，通知应用程序在哪里可以找到该功能。 规范 定义了 ENS 解析器的新解析类型，包括以下方法: function interfaceImplementer(bytes32 node, bytes4 interfaceID) external view returns (address); 该接口在 EIP-165 标准下的接口 ID 是 0xb8f2bbb4. 给定 ENS 名称的 namehash 值 node 和 EIP-165 interfaceID，此函数返回该接口的实现者的地址。如果没有与该节点的接口 ID 匹配的接口，则返回 0。 interfaceImplementer 返回的地址必须指向一个智能合约。 返回地址的智能合约应该实现 EIP-165。 实现此接口的解析器可以使用一种回退策略: 如果用户没有显式提供匹配的接口，则查询 addr() 返回的合约，如果请求的接口被该合约支持，则返回其地址，否则为 0。如果这样做，则必须确保在目标合约恢复时返回 0，而不是恢复。 此字段可用于正向解析和反向解析。 原理 解决这个问题的一种简单方法是将此方法直接添加到目标合约中。然而，这样做有几个缺点: 每个合约必须维护自己的接口实现列表。 修改此列表需要访问控制，而合约以前可能不需要访问控制。 这项支持必须在合约起草时就设计好，并且不能在合约起草后再进行修改。 只支持一个规范的接口列表。 而使用 ENS 解析器可以弱化这些缺点，使任何人都可以将接口与名称关联起来，即使是以前没有考虑到这一点的合约。 向后兼容性 不存在向后兼容性问题 实现 ensdomains/resolvers 中的公共解析器代码仓库实现了这个接口。 版权 通过 CC0 放弃版权及相关权利。 © Pengfei Ni all right reserved，powered by GitbookUpdated at 2022-05-17 21:04:39 "},"docs/ens-improvement-proposals/ensip-9-multichain-address-resolution.html":{"url":"docs/ens-improvement-proposals/ensip-9-multichain-address-resolution.html","title":"ENSIP-9: 多链地址解析","summary":"为 ENS 解析器的 `addr` 字段引入了新的重载，它允许将 ENS 解析至其他区块链的地址 (原来的 EIP-2304)。","keywords":"","body":" 作者 Nick Johnson \\nick@ens.domains 状态 完结 提交时间 2019-09-09 动机 随着多币钱包越来越多地使用 ENS，钱包开发者开始要求能够在 ENS 中解析非以太坊链的地址，本规范标准化了以跨客户端方式输入和检索这些地址的方法。 规范 为解析器指定了一个新的访问器函数: function addr(bytes32 node, uint coinType) external view returns(bytes memory); 此函数的 EIP-165 接口 ID 为 0xf1cb7e06。 在解析器上调用时，此函数必须按照指定的 namehash 和代币类型来返回相应的加密货币地址。如果指定的代币 ID 在指定的节点上不存在，则必须返回一个零长度的字符串。 coinType 是由 SLIP44 索引的的加密货币类型。 返回值是原始二进制格式的加密货币地址。下面的地址编码一节详细描述了几种常用链的二进制编码。 为解析器定义了一个新的事件: event AddressChanged(bytes32 indexed node, uint coinType, bytes newAddress); 解析器必须在每次更改名称和代币类型的地址时触发此事件。 访问器功能建议 下面介绍修改某个节点对应地址的推荐接口。解析器应该实现这个接口来设置地址，除非它们需要指定一个不同的接口。 function setAddr(bytes32 node, uint coinType, bytes calldata addr); setAddr 添加或替换指定节点和代币类型的地址。这个函数的参数与上面 addr() 中描述的一样。 这个函数触发一个带有新地址的 AddressChanged 事件，请参见下面的“向后兼容”部分中同时支持 addr(bytes32) 的解析器。 地址编码 一般来说，应该使用地址的原生二进制表示，而不是通常在文本表达式中使用的校验和。 本文提供了一个常见区块链的编码表，然后对每种格式进行了更详细的描述。表中的“编码”列出了该链支持的地址编码，以及相关的参数。这些地址编码的详细信息紧随其后。 币名 代币类型 编码 Bitcoin 0 P2PKH(0x00), P2SH(0x05), SegWit('bc') Litecoin 2 P2PKH(0x30), P2SH(0x32), P2SH(0x05), SegWit('ltc') Dogecoin 3 P2PKH(0x1e), P2SH(0x16) Monacoin 22 P2PKH(0x32), P2SH(0x05) Ethereum 60 ChecksummedHex Ethereum Classic 61 ChecksummedHex Rootstock 137 ChecksummedHex(30) Ripple 144 Ripple Bitcoin Cash 145 P2PKH(0x00), P2SH(0x05), CashAddr Binance 714 Bech32('bnb') P2PKH(版本) 用于支付的公钥哈希地址是经过 base58check 编码的。解码后，第一个字节是版本字节。例如，比特币地址 1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa 经过 base58check 解码为 21 字节的 0062e907b15cbf27d5425399ebf6f0fb50ebb88f18。 P2PKH 地址以一个版本字节开始，后面跟着 20 字节的公钥哈希。它们的规范编码是 scriptPubkey 编码，(参见 这里) 是 OP_DUP OP_HASH160 OP_EQUALVERIFY OP_CHECKSIG。 因此，上面的示例地址被编码为 25 字节的 76a91462e907b15cbf27d5425399ebf6f0fb50ebb88f1888ac。 P2SH(版本) P2SH 地址采用和 P2PKH 地址相同的方式进行 base58check 编码。P2SH 地址有一个版本字节，后面跟着 20 字节的哈希值。它们的 scriptPubkey 编码 (参见 这里) 是 OP_HASH160 OP_EQUAL。比特币地址 3Ai1JZ8pdJb2ksieUV8FsxSNVJCpoPi8W6 解码为 21 字节的 0562e907b15cbf27d5425399ebf6f0fb50ebb88f18 并被编码为 23 字节的 a91462e907b15cbf27d5425399ebf6f0fb50ebb88f1887。 SegWit(hrp) SegWit 地址使用 bech32 进行编码。Bech32 地址包括一个人类可读的部分 (代表比特币主网的“bc”) 和一个机器可读的部分。对于 SegWit 地址，会按照 BIP141 定义，解码为一个 0 到 15 之间的 “见证版本”，和一个“见证程序”。 由 BIP141 定义的 bech32 地址的 scriptPubkey 编码，是 OP_n，其中 n 是见证版本，后面是见证程序的 push 指令。注意BIP173 的警告: 实现在将地址转换为 scriptPubkey 时应该特别注意，其中见证版本 n 存储为OP_n。OP_0 被编码为 0x00，但是 OP_1 到 OP_16 被编码为 0x51 到 0x60 (十进制为 81 到 96)。如果 bech32 地址被转换为不正确的 scriptPubKey，结果可能是不可使用的或不安全的。 例如，比特币 SegWit 地址 BC1QW508D6QEJXTDG4Y5R3ZARVARY0C5XW7KV8F3T4 解码为版本 0 和见证脚本 751e76e8199196d454941c45d1b3a323f1433bd6，然后编码为 scriptPubkey 0014751e76e8199196d454941c45d1b3a323f1433bd6。 ChecksummedHex(chainId?) 要将文本格式的校验和十六进制地址转换为二进制格式，只需删除 '0x' 前缀并将其进行十六进制解码。0x314159265dD8dbb310642f98f50C066173C1259b 被十六进制解码并存储为 20 字节的 314159265dd8dbb310642f98f50c066173c1259b。 校验和格式由 EIP-55 指定，并经过 RSKIP60 扩展，它规定了在校验和中包含链 ID 的方法。要求必须检查文本格式地址上的校验和。如果地址的校验和不是全部大写或全部小写，则必须拒绝该地址并报错。相关实现可以选择是否接受非校验和地址，但其作者建议在这种情况下至少向用户提供警告。 当将一个地址从二进制编码为文本时，必须使用 EIP55/RSKIP60 校验和，所以上述地址的正确编码为 0x314159265dD8dbb310642f98f50C066173C1259b。 Ripple Ripple 地址使用 base58check 的一个版本进行编码，这个版本采用另一种字母表，在这里有相关介绍。它支持两种类型的 ripple 地址，'r-addresses' 和 'X-addresss'。r-addresses 由一个版本字节后跟 20 个字节的哈希值组成，而 X-addresses 由一个版本字节、20 个字节的哈希值和一个标记组成，参见这里。 这两种地址类型都应该通过执行 ripple 版本的 base58check 解码并直接存储在 ENS 中(包括版本字节)。例如，ripple 地址 rf1BiGeXwwQoi8Z2ueFYTEXSwuJYfV2Jpn 解码并存储为 004b4e9c06f24296074f7bc48f92a97916c6dc5ea9，而地址 X7qvLs7gSnNoKvZzNWUT2e8st17QPY64PPe7zriLNuJszeg 解码并存储为 05444b4e9c06f24296074f7bc48f92a97916c6dc5ea9000000000000000000。 CashAddr 比特币现金定义了一种名为 'CashAddr' 的新地址格式，参见这里。它使用 bech32 编码的变体来编码和解码 (非 segwit) 比特币现金地址，使用前缀'bitcoincash:'。CashAddr 应该使用这种 bech32 变体进行解码，然后根据其类型 (P2PKH 或 P2SH) 进行转换和存储，如上面的相关部分所述。 Bech32 Bech32 地址包括一个人类可读的部分 (例如，币安的 'bnb') 和一个机器可读的部分。编码后的数据只是地址，可以转换成二进制并直接存储。 例如 BNB 地址 bnb1grpf0955h0ykzq3ar5nmum7y6gdfl6lxfn46h2 解码为二进制表示形式 40c2979694bbc961023d1d27be6fc4d21a9febe6，直接存储在 ENS 中。 示例 下面是一个支持这个 ENSIP 的解析器的实现示例: pragma solidity ^0.5.8; contract AddrResolver is ResolverBase { bytes4 constant private ADDR_INTERFACE_ID = 0x3b3b57de; bytes4 constant private ADDRESS_INTERFACE_ID = 0xf1cb7e06; uint constant private COIN_TYPE_ETH = 60; event AddrChanged(bytes32 indexed node, address a); event AddressChanged(bytes32 indexed node, uint coinType, bytes newAddress); mapping(bytes32=>mapping(uint=>bytes)) _addresses; /** * Sets the address associated with an ENS node. * May only be called by the owner of that node in the ENS registry. * @param node The node to update. * @param a The address to set. */ function setAddr(bytes32 node, address a) external authorised(node) { setAddr(node, COIN_TYPE_ETH, addressToBytes(a)); } /** * Returns the address associated with an ENS node. * @param node The ENS node to query. * @return The associated address. */ function addr(bytes32 node) public view returns (address) { bytes memory a = addr(node, COIN_TYPE_ETH); if(a.length == 0) { return address(0); } return bytesToAddress(a); } function setAddr(bytes32 node, uint coinType, bytes memory a) public authorised(node) { emit AddressChanged(node, coinType, a); if(coinType == COIN_TYPE_ETH) { emit AddrChanged(node, bytesToAddress(a)); } _addresses[node][coinType] = a; } function addr(bytes32 node, uint coinType) public view returns(bytes memory) { return _addresses[node][coinType]; } function supportsInterface(bytes4 interfaceID) public pure returns(bool) { return interfaceID == ADDR_INTERFACE_ID || interfaceID == ADDRESS_INTERFACE_ID || super.supportsInterface(interfaceID); } } 实现 ensdomains/resolvers 仓库提供了该接口的实现。 向后兼容性 如果解析器支持 ENSIP-1 中定义的 addr(bytes32) 接口，那它必须按照以下方式将其作为新规范的特殊情况处理: ENSIP-1 中 addr(node) 返回的值应该始终匹配 addr(node, 60) 返回的值 (60 是以太坊的代币类型 ID)。 任何触发 ENSIP-1 的 AddressChanged 事件也必须触发本 ENSIP 中的 AddressChanged 事件，其中 coinType 指定为 60，反之亦然。 测试 下表为上述每种加密货币的有效地址编码指定了测试向量。 币名 代币类型 文本 链上地址 (十六进制) Bitcoin 0 1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa 76a91462e907b15cbf27d5425399ebf6f0fb50ebb88f1888ac 3Ai1JZ8pdJb2ksieUV8FsxSNVJCpoPi8W6 a91462e907b15cbf27d5425399ebf6f0fb50ebb88f1887 BC1QW508D6QEJXTDG4Y5R3ZARVARY0C5XW7KV8F3T4 0014751e76e8199196d454941c45d1b3a323f1433bd6 Litecoin 2 LaMT348PWRnrqeeWArpwQPbuanpXDZGEUz 76a914a5f4d12ce3685781b227c1f39548ddef429e978388ac MQMcJhpWHYVeQArcZR3sBgyPZxxRtnH441 a914b48297bff5dadecc5f36145cec6a5f20d57c8f9b87 ltc1qdp7p2rpx4a2f80h7a4crvppczgg4egmv5c78w8 0014687c150c26af5493befeed7036043812115ca36c Dogecoin 3 DBXu2kgc3xtvCUWFcxFE3r9hEYgmuaaCyD 76a9144620b70031f0e9437e374a2100934fba4911046088ac AF8ekvSf6eiSBRspJjnfzK6d1EM6pnPq3G a914f8f5d99a9fc21aa676e74d15e7b8134557615bda87 Monacoin 22 MHxgS2XMXjeJ4if2PRRbWYcdwZPWfdwaDT 76a9146e5bb7226a337fe8307b4192ae5c3fab9fa9edf588ac Ethereum 60 0x314159265dD8dbb310642f98f50C066173C1259b 314159265dd8dbb310642f98f50c066173c1259b Ethereum Classic 61 0x314159265dD8dbb310642f98f50C066173C1259b 314159265dd8dbb310642f98f50c066173c1259b Rootstock 137 0x5aaEB6053f3e94c9b9a09f33669435E7ef1bEAeD 5aaeb6053f3e94c9b9a09f33669435e7ef1beaed Ripple 144 rf1BiGeXwwQoi8Z2ueFYTEXSwuJYfV2Jpn 004b4e9c06f24296074f7bc48f92a97916c6dc5ea9 X7qvLs7gSnNoKvZzNWUT2e8st17QPY64PPe7zriLNuJszeg 05444b4e9c06f24296074f7bc48f92a97916c6dc5ea9000000000000000000 Bitcoin Cash 145 1BpEi6DfDAUFd7GtittLSdBeYJvcoaVggu 76a91476a04053bda0a88bda5177b86a15c3b29f55987388ac bitcoincash:qpm2qsznhks23z7629mms6s4cwef74vcwvy22gdx6a 76a91476a04053bda0a88bda5177b86a15c3b29f55987388ac 3CWFddi6m4ndiGyKqzYvsFYagqDLPVMTzC a91476a04053bda0a88bda5177b86a15c3b29f55987387 bitcoincash:ppm2qsznhks23z7629mms6s4cwef74vcwvn0h829pq a91476a04053bda0a88bda5177b86a15c3b29f55987387 Binance 714 bnb1grpf0955h0ykzq3ar5nmum7y6gdfl6lxfn46h2 40c2979694bbc961023d1d27be6fc4d21a9febe6 版权 通过 CC0 放弃版权及相关权利。 © Pengfei Ni all right reserved，powered by GitbookUpdated at 2022-05-17 21:04:39 "},"docs/ens-improvement-proposals/ensip-10-wildcard-resolution.html":{"url":"docs/ens-improvement-proposals/ensip-10-wildcard-resolution.html","title":"ENSIP-10: 通配符解析","summary":"Provides a mechanism to support wildcard resolution of ENS names (formerly EIP-2544).","keywords":"","body":" 作者 Nick Johnson \\nick@ens.domains, 0age (@0age) 状态 草案 提交时间 2020-02-28 摘要 以太坊名称服务规范 (ENSIP-1) 确定了名称解析过程分为两个步骤。首先，ENS 客户端对名称执行 namehash 算法，确定名称对应的“节点”，随后将该节点提供给 ENS 注册表合约来找到这个名称的解析器。这时，如果在注册表上已经设置了解析器，客户端将向解析器合约提供同一个节点，解析器就会返回相应的地址或其他记录。 按照当前的规范，如果在 ENS 注册表中没有为给定的节点设置解析器，那么解析过程就会结束。此 ENSIP 将会更改名称解析的过程，它会为那些没有设置解析器的域添加一个额外的步骤。这个步骤从名称中除去最左边的标签，派生出新名称片段的节点，并将该节点提供给 ENS 注册表。如果找到了该节点的解析器，客户端将向该解析器合约提供原始的、完整的节点，以获取相应的记录。此步骤重复执行，直到找到具有解析器的节点。 此外，该规范为解析器定义了一种解析名称的新方法，统一使用能够更灵活地处理名称解析的 resolve() 方法。 动机 许多应用程序，如钱包提供商、交易所和 dapp 都表示希望通过共享父域上的自定义子域向用户分发 ENS 名称。然而目前，这样做必须在 ENS 注册表上为每个子域设置一个不同的记录，因此对于拥有巨量用户群体的应用程序来说，成本就成了限制因素。 此外，由于为子域节点分配解析器的交易必须先在链上提交和打包，因此用户不能在创建帐户时立即使用这些子域。这给新用户造成了不必要的障碍，而这些新用户将会从 ENS 名称的可用性改进中获益。 通配符的启用能够支持设计更高级的解析器，为未分配的子域确定性地生成地址和其他记录。生成的地址可以映射到反事实的合约部署地址 (即 CREATE2 地址) 或指定的“回退”地址，或者其他方案。此外，仍然可以给任何指定的子域分配独立的解析器，这将使用父解析器取代通配符解析。 这项标准的另一个关键动机是以向后兼容的方式支持通配符解析。它不需要修改当前 ENS 注册表合约或任何现有的解析器，并继续支持现有的 ENS 记录，只是旧的 ENS 客户端将无法解析通配符记录。 规范 本文档中的关键词 “必须”、“绝对不能”、“必需”、“会”、“不会”、“应该”、“不应”、“推荐”、“可以”和“可选”应按照 RFC 2119 中的描述进行解释。 设: namehash 是 ENSIP-1 中定义的算法。 dnsencode 是 RFC1035 3.1 节中指定的 DNS 域名的编码过程，但编码后的名称的总长度没有限制。空字符串作为一个 0 长度的 8 位元组，与名称 '.' 编码相同。 parent 是一个函数，用于删除一个名称的第一个标签 (例如，parent('foo.eth') = 'eth')。parent('tld') 被定义为空字符串。 ens 是当前网络的 ENS 注册表合约。 兼容 ENSIP-10 的 ENS 解析器可以实现以下功能接口: interface ExtendedResolver { function resolve(bytes calldata name, bytes calldata data) external view returns(bytes); } 如果一个解析器实现了这个函数，那么在 supportsInterface() 被调用且传入 0x9061b923 这个接口 ID 时，它必须返回 true。 ENS 客户端将调用 resolve 并传入需要解析的 DNS 编码名称和用于解析器函数的编码后的调用数据 (比如 ENSIP-1 和其他地方指定的)，该函数必须返回有效的数据，或在不支持的情况下进行回退。 兼容 ENSIP-10 的 ENS 客户端在获取给定名称的解析器时必须执行以下步骤: 设置 currentname = name 设置 resolver = ens.resolver(namehash(currentname)) 如果 resolver 不是零地址，则停止并返回 resolver。 如果 currentname 为空 ('' 或 '.')，则停止并返回 null。 其他情况下，设置 currentname = parent(currentname) 并进入第 2 步。 如果上面的过程返回 null，名称解析必须终止。其他情况下，兼容 ENSIP-10 的 ENS 客户端解析一条记录时必须执行以下步骤: 将 calldata 设置为解析函数对应的 ABI 编码数据——例如，解析 addr 记录时，设置为 addr(namehash(name)) 的 ABI 编码。 设置 supportsENSIP10 = resolver.supportsInterface('0x9061b923')。 如果 supportsENSIP10 为 true，则设置 result = resolver.resolve(dnsencode(name), calldata)。 如果 supportsENSIP10 为 false 且 name == currentname，则将 result 设置为使用 calldata 作为调用 resolver 获得的结果。 如果 3 和 4 均不为 true，以失败结束。 使用对应的解析函数的返回数据 ABI 解码后，返回 result (例如，对于 addr()， resolver.resolve() 的结果经 ABI 解码为 address)。 请注意，在所有情况下，解析函数 (addr() 等) 和 resolve 函数都使用了原来的 name， 而不是在解析的第一阶段找到的 currentname。 还要注意的是，当使用通配符解析时 (例如，name != currentname)，客户端绝对不能调用传统方法，如 addr 来解析名称。这些方法只能在与 name 精确匹配的解析器中调用。 伪代码 function getResolver(name) { for(let currentname = name; currentname !== ''; currentname = parent(currentname)) { const node = namehash(currentname); const resolver = ens.resolver(node); if(resolver != '0x0000000000000000000000000000000000000000') { return [resolver, currentname]; } } return [null, '']; } function resolve(name, func, ...args) { const [resolver, resolverName] = getResolver(name); if(resolver === null) { return null; } const supportsENSIP10 = resolver.supportsInterface('0x9061b923'); if(supportsENSIP10) { const calldata = resolver[func].encodeFunctionCall(namehash(name), ...args); const result = resolver.resolve(dnsencode(name), calldata); return resolver[func].decodeReturnData(result); } else if(name == resolverName) { return resolver[func](...args); } else { return null; } } 原理 实现本提案将会以一种对现有系统影响最小化的方式支持通配符解析。它最大程度上重用了现有的算法和过程，从而减轻了各种 ENS 客户端的作者和维护人员的负担。 它也承认当前关于 ENS 通配符解析的共识，通过解决关键的可伸缩性障碍，使原有规范得到更广泛的采用。 为解析器引入可选的 resolve 函数，在解析函数中传入了名称和 calldata，这些增加了实现的复杂性，但也为解析器提供了一种方法来获取明文标签并执行相应的程序，使得原本许多不可能实现的通配符相关用例变得可能——例如，通配符解析器可以将 id.nifty.eth 指向某个集合中 id 为 id 的 NFT 的所有者，而如果只使用名称集，这是不可能的。 DNS wireformat 用于名称编码，因为它能够快速且高效地进行名称哈希，以及其他类似获取或删除单个标签的常见操作，相反，点分隔的名称需要遍历名称中的每个字符来找到分隔符。 向后兼容性 兼容 ENSIP-1 的现有 ENS 客户端将无法解析通配符记录并拒绝与之交互，而符合 ENSIP-10 的客户端将继续正确解析或拒绝现有 ENS 记录。希望为非通配符的用例实现新的 resolve 函数 (例如，解析器直接设置在被解析的名称上) 的解析器，应该考虑将什么返回给调用单个解析函数的旧客户端，以获得最大的兼容性。 要求客户端避免在通配符解析器上调用现有的解析函数 (如 addr 等)，可以防止解析器在返回所有名称的查询时出现意外的向后兼容问题。 安全注意事项 尽管兼容的 ENS 客户端在没有解析器的情况下会拒绝解析记录，但仍然会存在错误配置的客户端引用错误解析器的风险，或者在无法获取解析器时继续与空地址进行交互。 此外，对于完全支持任意通配符子域解析的解析器来说，由于输入错误而将资金意外发送给其他接收者的可能性将会增加。实现这种解析器的应用程序应该考虑根据上下文为客户提供额外的名称验证，或者实现支持资金找回的功能。 还有一种可能性是，一些应用程序可能需要不给某些子域设置解析器。如果要解决这个问题，父域需要正确解析给定的子域节点——据作者所知，目前没有应用程序支持此特性或期望子域不要解析到某条记录。 版权 通过 CC0 放弃版权及相关权利。 © Pengfei Ni all right reserved，powered by GitbookUpdated at 2022-05-17 21:04:39 "},"docs/ens-improvement-proposals/ensip-11-evmchain-address-resolution.html":{"url":"docs/ens-improvement-proposals/ensip-11-evmchain-address-resolution.html","title":"ENSIP-11: 兼容链地址解析","summary":"引入 EVM 兼容链的代币类型 (修订 ENSIP9)。","keywords":"","body":" 作者 Makoto Inoue \\makoto@ens.domains 状态 草案 提交时间 2022-01-13 摘要 这个 ENSIP 扩展了 ENSIP 9 (多链地址解析)，为兼容 EVM 的链规定了一系列代币类型，并指定了一种将 EVM 链 ID 派生到指定代币类型的方法。 专用范围使用超过 0x80000000 (2147483648)，这是在 ENSIP 9 下保留的，因此代币类型不可能出现冲突，其他非 EVM 代币类型会在未来增加。然而，一些以前分配给 EVM 链 ID 的代币类型将被弃用。 动机 现有的 ENSIP 9 依赖于 SLIP44 上存在的代币类型，它被设计用来为确定性钱包定义地址编码类型。由于大多数 EVM 兼容链继承与以太坊相同的编码类型，因此不断请求将 EVM 兼容链添加到 SLIP 44 中是多余的。本规范标准化了一种基于链 ID 派生出代币类型的方法。 规范 该规范修正了 ENSIP 9，规定具有最高有效位集的代币类型将被视为 EVM 链 ID。MSB 在 SLIP44 中保留，用于其他与 HD 钱包密钥派生相关的用途，因此在这个范围内不存在代币类型。 计算 EVM 链的新代币类型时，将链 ID 和 0x80000000 进行“位-或”计算: 0x80000000 | chainId。 export const convertEVMChainIdToCoinType = (chainId: number) =>{ return (0x80000000 | chainId) >>> 0 } 反向操作时，将代币类型和 0x7fffffff 进行“位-与”计算: 0x7fffffff & coinType。 export const convertCoinTypeToEVMChainId = (coinType: number) =>{ return (0x7fffffff & coinType) >> 0 } 实现 ensdomains/address-encoder 仓库中提供了该接口的实现。 示例 要为 EVM 链计算新的代币类型，需调用 convertEVMChainIdToCoinType(chainId) const encoder = require('@ensdomains/address-encoder') > encoder.convertEVMChainIdToCoinType(61) 2147483709 > encoder.convertCoinTypeToEVMChainId(2147483709) 61 你也可以使用现有的 formatsByName 和 formatsByCoinType 函数来派生这些链 ID > encoder.formatsByName['XDAI'] { coinType: 2147483748, decoder: [Function (anonymous)], encoder: [Function (anonymous)], name: 'XDAI' } > encoder.formatsByCoinType[2147483748] { coinType: 2147483748, decoder: [Function (anonymous)], encoder: [Function (anonymous)], name: 'XDAI' } 例外 以下 EVM 链是这个标准的例外。 AVAX = AVAX 有多链地址格式，只有 c 链兼容 EVM RSK = RSK 有自己的额外验证 他们将继续使用在 SLIP44 定义的代币类型 向后兼容性 在引入这个新标准之前，存在以下 EVM 兼容的类型。 NRG POA TT CELO CLO TOMO EWT THETA GO FTM XDAI ETC 出于向后兼容的目的显示它们时，将 _LEGACY 附加到代币类型并使其为只读。 版权 通过 CC0 放弃版权及相关权利。 © Pengfei Ni all right reserved，powered by GitbookUpdated at 2022-05-17 21:04:39 "},"docs/ens-improvement-proposals/ensip-12-avatar-text-records.html":{"url":"docs/ens-improvement-proposals/ensip-12-avatar-text-records.html","title":"ENSIP-12: 头像文本记录","summary":"在 ENS 中存储头像文本记录的标准。","keywords":"","body":" 作者 Nick Johnson \\nick@ens.domains, Makoto Inoue \\makoto@ens.domains 状态 草案 提交时间 2022-01-18 摘要 这个 ENSIP 定义了从 ENS 检索头像 URI 的过程、ENS 'avatar' 文本字段的几个 URI 方案，以及希望显示用户头像的客户端应该如何解译这些方案。 动机 ENS 主名称 (以前称为反向记录) 已经被广泛集成为许多基于以太坊的应用程序的 web3 用户名。随着多个应用程序开始指定头像并允许用户将 NFT 作为头像，现在将头像信息存储在 ENS 中以便在不同应用程序之间共享头像信息的做法已经司空见惯。 该规范使用 ENSIP-5: 头像文本记录将存储和检索这些信息的方法进行了标准化。 规范 检索头像 URI 检索头像 URI 的过程取决于客户端是否从以太坊地址或 ENS 名称开始。 ENS 名称 为了确定一个 ENS 名称的头像 URI，客户端必须首先在解析器中查找这个名称并调用 .text(namehash(name), 'avatar') 来检索这个名称的头像 URI。 客户端必须将以下情况视为找不到有效的头像 URI：解析器不存在；在解析器上调用 addr 方法时遇到的回退；或者解析器返回空字符串。 以太坊地址 为了确定一个以太坊地址的头像 URI，客户端必须通过在 ENS 注册表中查询 .addr.reverse 的解析器来反向解析这个地址，其中 是小写十六进制编码的以太坊地址，不带 '0x'。然后，客户端调用 .text(namehash('.addr.reverse'), 'avatar') 来检索该地址的头像 URI。 如果一个解析器返回了反向记录，但是调用 text 时发生回退或返回一个空字符串，客户端必须调用 .name(namehash('.addr.reverse'))。如果这个方法返回一个有效的 ENS 名称，客户端必须: 通过解析返回的名称并在解析器上调用 addr，检查它是否与原始以太坊地址匹配，以此来验证反向记录是有效的。 执行上文中 'ENS 名称' 部分描述的过程，查找名称对应的有效的头像 URI。 这个过程中任何一步遇到失败都必须被客户端视为找不到有效的头像 URI。 通用格式 'avatar' 文本字段必须格式化为 URI。客户端必须忽略他们不能识别的 URI 类型，将它们看作没有设置该字段一样。 图像类型 客户端必须支持 mime 类型为 image/jpeg、image/png 和 image/svg+xml 的图像。客户端可以支持其他的图像类型。 URI 类型 所有客户端都应该支持下面定义的 URI 方案。它们可以实现本规范中未定义的附加方案。 https 如果提供的是 https URI，它必须直接解析为头像图像。https URL 不能解析为 HTML 页面、元数据或其他包含头像的内容。 ipfs 如果提供的是 ipfs URI，它必须直接解析为头像图像。没有内置 IPFS 支持的客户端可以在解析为 https URL 之前，将 URI 重写为引用 IPFS 网关的 https URL，如这篇文档所述。 data 如果提供的是 data URL，它必须直接解析为头像图像。 NFT 对 NFT 的引用可以作为头像 URI 使用，遵循在 CAIP-22 和 CAIP-29 中定义的标准。 客户端必须至少支持 ERC721 和 ERC1155 类型的 NFT，并且可以支持其他类型的 NFT。 要解析 NFT URI，客户端遵循以下过程: 检索 avatar 字段 URI 中指定的代币的元数据 URI。 解析元数据 URI，获取 ERC721 或 ERC1155 元数据。 提取 NFT 元数据中指定的图像 URL。 解析图像 URL 并使用它作为头像。 客户端必须至少支持 https 和 ipfs URI 来解析元数据 URI 和头像，并且可以支持其他的方案。客户端可以通过如上所述将 URI 重写为引用 IPFS 网关的 HTTPS URL 来实现 ifps 方案的支持。 客户端还应采取以下验证步骤: 在通过正向解析 (从 ENS 名称开始) 检索头像 URI 的位置，在同一个解析器上针对同一个名称调用 addr 函数，来检索名称解析到的以太坊地址。否则，如果头像 URI 是通过反向解析 (从以太坊地址开始) 检索的，则使用该地址。 验证步骤 1 中的地址是 URI 中指定的 NFT 的所有者。如果不是，客户端必须将 URI 视为无效，并按照与没有指定头像 URI 时相同的方式进行处理。 客户端可以通过重写为 https URI 来支持 NFT 头像解析服务。 示例 以下示例均解析至同一个头像图片: eip155:1/erc721:0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d/0 # BAYC token 0 ipfs://QmRRPWG96cmgTn2qSzjwr2qvfNEuhunv6FNeMFGa9bx6mQ # IPFS hash for BAYC token 0 image https://ipfs.io/ipfs/QmRRPWG96cmgTn2qSzjwr2qvfNEuhunv6FNeMFGa9bx6mQ # HTTPS URL to IPFS gateway for BAYC token 0 image 向后兼容性 不适用。 安全注意事项 无。 版权 通过 CC0 放弃版权及相关权利。 © Pengfei Ni all right reserved，powered by GitbookUpdated at 2022-05-17 21:04:39 "},"docs/dapp-developer-guide/ens-enabling-your-dapp.html":{"url":"docs/dapp-developer-guide/ens-enabling-your-dapp.html","title":"在 DAPP 中启用 ENS","keywords":"","body":"在应用程序中支持 ENS 需要实现几个关键功能，每个功能都可以独立实现。理想的情况是支持 ENS 的全部功能，但即使只支持最基本的功能也会让用户从中获益匪浅。下面的文章中，我们概述了支持 ENS 的三个层级。第一层级很容易实现，并且是 ENS 提供给用户的主要功能，而第二层级和第三层级可为用户提供更多的功能，有助于提高 DApp 的可用性和用户与 DApp 交互的体验。 1. ENS 名称解析 在应用程序中支持 ENS 的第一步是使应用程序理解 ENS 名称，并实现在那些用来输入接收地址的地方也可以输入 ENS 名称。要了解如何做到这一点，请参阅 名称解析。 当用户输入 ENS 名称而不是地址时，最好让应用程序记住 ENS 名称，而不是这个名称解析到的地址。这样用户在更新自己的 ENS 名称后，他们用这个名称登录的应用就会自动解析到用户的新地址。同样的道理，如果你访问的网站更换了服务器 IP 地址，你肯定是希望浏览器把你带到这个网站的新 IP 地址上。 如果你的应用程序需要处理用户的资产等关键资源，你可能希望跟踪名称解析到的地址，并在地址更改时提示用户，以确认用户知道地址的变化。 你的应用程序支持 ENS 名称以后，就不需要用户复制粘贴或是直接输入冗长晦涩的以太坊地址。尤其是直接输入以太坊地址，很容易导致输入错误和资产损失。 2. 支持反向解析 支持 ENS 的第二个层级是指：在程序中本来显示地址的地方可以显示出对应的 ENS 名称。 如果用户在你的 DApp 中输入了 ENS ，你应该保存这个名称，并将这个名称显示在那些本来要向用户显示地址的地方。 如果用户输入了一个地址，或是从其他地方收到一个地址，你可以通过执行 反向解析 来显示 ENS 名称。反向解析支持查询地址的规范化名称，并在需要时显示该名称。如果查询不到对应的规范化名称，那应用程序可以像原来那样直接显示地址。 通过支持反向解析，可以使用户更容易地识别与他们进行交互的帐户，并将这些账户与可读且相对短小的名称关联起来，而不是让用户面对冗长晦涩的以太坊地址。 3. 让用户自定义名称 全面支持 ENS 的最后一步是促进 ENS 名称与应用程序内置资源之间的关联。这可以通过两种形式来实现： 名称注册 先给你的产品绑定 ENS 名称并允许用户轻松地注册子名称，通过这种方式可以为用户提供一种简单的命名方法，用来命名那些在你的 DApp 中创建的资源。例如，假设你的 DApp 是一个加密货币钱包，你可以让用户轻松地获得一个形如 theirname.yourwallet.eth 的 ENS 名称，使用户更容易把自己的钱包名告诉别人。 要了解如何实现这项功能，请参阅在 “智能合约开发者指南” 部分中的 编写一个注册器 一文。 名称更新 通过为用户提供一种简便的名称更新方式，以便他们将自己的名称更新并指向你的 DApp 内的资源。要了解如何实现这项功能请参阅 名称管理。 将支持 ENS 的应用告诉我们 如果你的应用程序已经支持使用 ENS，请通过电子邮件 nick@ens.domains 告诉我们；我们会把你的应用程序添加到 我们的主页。 © Pengfei Ni all right reserved，powered by GitbookUpdated at 2022-05-17 21:04:39 "},"docs/dapp-developer-guide/ens-libraries.html":{"url":"docs/dapp-developer-guide/ens-libraries.html","title":"ENS 库","keywords":"","body":"ENS 支持多种主流语言。如果有些你知道的 ENS 库没有在本页面陈列出来，请 向我们发起 PR（pull request）。 Javascript ensjs，由 ENS 开发者维护 ethereum-ens（不推荐） react-ens-address ethers.js web3.js embark.io waffle.io 我应该使用哪个 Javascript 库 如果你用过 web3.js 或 ethers.js ，并且不需要使用创建子名称、转移所有权或更新解析器等功能，那么你可以使用这些库内置的 ENS 特性。 如果你在用 React ，并且只需要在 UI 界面中对 ENS 名称进行正向和反向解析，那么你可以使用 react-ens-address。 如果你用过 ethers.js ，并且只需要对 ENS 名称进行正向和反向解析，那么你可以使用 ethers.js 库中对 ENS 的支持。 如果你想要将 ENS 实例部署到您的开发环境中，那么你可以使用 embark.io 或 waffle.io ，它们可以让你在以太坊测试实例中配置和部署 ENS 注册表。 其他情况下，建议使用 ensjs 库。 直接访问智能合约 当前所有的 ENS 智能合约都是作为 @ensdomains/ens-contracts npm 模块 发布的。 在前端代码中包含 ABI 的方法： import { ENS, PublicResolver } from '@ensdomains/ens-contracts'` 在 Solidity 中导入 ENS 智能合约的方法： import '@ensdomains/ens-contracts/contracts/registry/ENS.sol'; Java web3j Kotlin KEthereum Python web3.py - also see web3.py ENS docs Go go-ens Command-line ethereal Delphi delphereum 后续工作 选定使用哪个库以后，就可以通过阅读 ENS 的使用 ，来学习如何在应用程序中使用你选择的 ENS 库。 © Pengfei Ni all right reserved，powered by GitbookUpdated at 2022-05-17 21:04:39 "},"docs/dapp-developer-guide/working-with-ens.html":{"url":"docs/dapp-developer-guide/working-with-ens.html","title":"ENS 的使用","keywords":"","body":"在开始与 ENS 交互之前，首先要引用 ENS 注册表，引用 ENS 注册表的方式取决于你使用了哪个 ENS 库。 下面的代码是基于 Javascript 的 API（ensjs、web3.js、ethjs-ens和ethers.js）的使用示例，这些代码适合运行在一个引入了 ethereum 对象的 DApp 浏览器中，比如安装了 metamask 的 Chrome。 采用 ensjs 时： import ENS, { getEnsAddress } from '@ensdomains/ensjs' const ens = new ENS({ provider, ensAddress: getEnsAddress('1') }) 采用 web3.js 时： var Web3 = require(\"web3\") var accounts = ethereum.enable(); var web3 = new Web3(ethereum); var ens = web3.eth.ens; 采用 ethjs-ens 时： const ENS = require('ethjs-ens'); // Currently requires both provider and // either a network or registryAddress param var accounts = ethereum.enable(); const ens = new ENS({ ethereum, network: '1' }); 采用 ethers.js 时： var ethers = require('ethers'); var provider = new ethers.providers.Web3Provider(ethereum); // ENS functionality is provided directly on the core provider object. 采用 go-ens 时： import ( ens \"github.com/wealdtech/go-ens/v2\" ethereum \"github.com/ethereum/go-ethereum\" ) // Can dial up a connection through either IPC or HTTP/HTTPS client, err := ethereum.Dial(\"/home/ethereum/.ethereum/geth.ipc\") registry, err := ens.Registry(client) 采用 web3.py 时： from ens.auto import ns 采用 web3j 时： EnsResolver ens = new EnsResolver(web3j, 300 /* sync threshold, seconds */); 一些 web3 库（例如 ethers.js 、web3j 和 web3.py）已经内置了对名称解析的支持。在这些库中，只要可以使用地址的地方，都可以直接使用 ENS 名称，也就是说，除非你想手动解析名称或是进行其他特殊的 ENS 操作，否则你根本不需要直接与它们的 ENS API 交互。 如果你的平台没有可用的库，你可以使用 这里 的接口定义直接实例化 ENS 注册表合约。在 ENS 部署情况 页面中可以找到各个网络的 ENS 注册表地址。 © Pengfei Ni all right reserved，powered by GitbookUpdated at 2022-05-17 21:04:39 "},"docs/dapp-developer-guide/resolving-names.html":{"url":"docs/dapp-developer-guide/resolving-names.html","title":"名称解析","keywords":"","body":"ENS 名称空间包括 .eth 名称（ENS 原生名称）和 由 DNS 导入 ENS 的名称。由于 DNS 域名空间会随着时间的推移而增加，因此采用硬编码的名称后缀列表来识别 ENS 名称就会经常过时，导致应用程序不能识别所有有效的 ENS 名称。为了保证长期可用性，要正确集成 ENS，则需要将任何以点分隔的名称视为潜在的 ENS 名称，并将进行查询。 解析至加密货币的地址 ENS 名称可以关联至多种数据类型，最常见的是加密货币地址。ENS 支持存储和解析任意区块链的地址。 借助 ENS 库，将名称解析为以太坊地址很简单： 采用 ensjs 时： var address = await ens.name('resolver.eth').getAddress(); 采用 web3.js 时： var address = ens.getAddress('alice.eth'); 采用 ethjs-ens 时： var address = await ens.lookup('alice.eth'); 采用 ethers.js 时： var address = await provider.resolveName('alice.eth'); ethers.js 还能支持在任何需要使用地址的地方也可以使用 ENS 名称，也就是说一般不需要直接调用 resolveName 。例如，要查询一个账户的余额，你可以这样做: var balance = await provider.getBalance('alice.eth'); 或者，实例化一个合约: const abi = [ \"function getValue() view returns (string value)\", \"function setValue(string value)\" ]; const contract = new ethers.Contract('contract.alice.eth', abi, provider); 采用 go-ens 时： address, err := ens.Resolve(client, \"alice.eth\") 采用 web3.py 时： address = ns.address('alice.eth') 采用 web3j 时： String address = ens.resolve(\"alice.eth\"); web3j 同样支持在任何需要使用地址的地方也可以使用 ENS 名称，所以你通常不需要直接与 EnsResolver 对象交互。例如，要实例化一个合约接口，你可以这样做： YourSmartContract contract = YourSmartContract.load( \"contract.alice.eth\", web3j, credentials, GAS_PRICE, GAS_LIMIT); 如果不借助 ENS 库，解析的过程可以分为三步： 对将要解析的名称进行规范化和哈希，详细信息请参阅 名称处理。 在 ENS 注册表上调用 resolver() ，并将第 1 步输出的哈希作为参数传递，然后 resolver() 会返回负责解析这个名称的解析器的地址。 使用 resolver 接口 ，在第 2 步返回的解析器地址上调用 addr() ，并将第1步输出的哈希作为参数传递。 对其他区块链地址的支持是通过重载 addr() 来实现的。要解析非以太坊的地址，必须要有相应加密货币的 Namehash 和符合 SLIP44 规范的链 ID 。例如，要解析一个比特币地址，可以调用 addr(hash, 0) 。注意，返回的地址是用二进制表示的，因此要通过解码来得到文本格式的地址，详细内容请参阅 EIP2304 。 使用 addr() 进行解析时，必须将来自解析器 0x00…00 的返回值视为未设置的记录。否则，在用户配置了解析器却没有为名称设置解析地址的情况下，可能导致用户的资金被发送到空地址! 解析至其他资源 除了以太坊地址，ENS 还支持将名称解析至许多其他类型的资源，其中包括其他加密货币的地址、内容哈希（存储在 IPFS、Skynet、Swarm 或 Tor .onion 的内容的哈希）、合约接口（ABIs）和基于文本的元数据。查询这些信息的过程因采用的ENS库而有所差异，相关信息，请参阅所选库的文档。 如果不借助 ENS 库来实现这些类型的解析，同样需要遵循上面介绍过的3步过程，只是在第 3 步中调用的不再是 addr() ，而是解析器上与这些类型相对应的函数。 采用 ensjs 时： // Getting contenthash await ens.name('abittooawesome.eth').getContent() // Setting contenthash await ens.name('abittooawesome.eth').setContenthash(contentHash) // Getting other coins await ens.name('brantly.eth').getAddress('BTC') // Setting other coins await ens.name('superawesome.eth').setAddress('ETC', '0x0000000000000000000000000000000000012345') // Getting text await ens.name('resolver.eth').getText('url') // Setting text await ens.name('superawesome.eth').setText('url', 'http://google.com') 采用 web3.js 时： // Getting contenthash web3.eth.ens.getContenthash('ethereum.eth').then(function (result) { console.log(result); }); // Setting contenthash web3.eth.ens.setContenthash('ethereum.eth', hash); 采用 ethjs-ens 时： Not supported. 采用 ethers.js 时： const contentHash = await resolver.getContentHash(); const btcAddress = await resolver.getAddress(0); const dogeAddress = await resolver.getAddress(3); const email = await resolver.getText(\"email\"); 采用 go-ens 时： // Encoding bin, err := ens.StringToContenthash(\"/ipfs/QmayQq2DWCkY3d4x3xKh4suohuRPEXe2fBqMBam5xtDj3t\") // Setting contenthash resolver.SetContenthash(opts, data) // Getting contenthash resolver.Contenthash() // Decoding repr, err := ens.ContenthashToString(bin) // Getting Multicoin btcAddress, err := resolver.MultiAddress(0) // Setting Multicoin resolver.SetMultiAddress(opts, address) // Setting text resolver.SetText(opts, name, value) // Getting text resolver.Text(name) 采用 web3.py 时： Not supported. 采用 web3j 时： Not supported. contenthash（内容哈希）的编码/解码 contenthash 用于存储 IPFS 和 Swarm 内容哈希，我们可以将 ENS 地址解析为托管在这些分布式网络上的分布式内容（比如网站）。content-hash javascript 库提供了一种方便的方式来对这些哈希进行编码/解码。 const contentHash = require('content-hash') const encoded = 'e3010170122029f2d17be6139079dc48696d1f582a8530eb9805b561eda517e22a892c7e3f1f' const content = contentHash.decode(encoded) // 'QmRAQB6YaCyidP37UdDnjFY5vQuiBrcqdyoW1CuDgwxkD4' const onion = 'zqktlwi4fecvo6ri' contentHash.encode('onion', onion); // 'bc037a716b746c776934666563766f367269' const encoded = 'e40101701b20d1de9994b4d039f6548d191eb26786769f580809256b4685ef316805265ea162' const codec = contentHash.getCodec(encoded) // 'swarm-ns' codec === 'ipfs-ns' // false 对于 IPFS 需要注意：出于安全原因，IPFS 只能由编解码器 libp2p-key \b来进行编码。使用其他格式进行编码后，在解码时会显示不可用的警告。更多细节请阅读这里。 币种的编码/解码 尽管有些库可以通过符号（例如：BTC）查询这类加密货币地址，但其他库却没有内置这类支持，因此必须通过每个币种的 id 进行调用（例如：0 代表 BTC、16 代表 ETH），对于 Javascript/Typescript，可以使用 @ensdomains/address-encoder 库来进行转换。 import { formatsByName, formatsByCoinType } from '@ensdomains/address-encoder'; formatsByName['BTC'] // { // coinType: 0, // decoder: [Function (anonymous)], // encoder: [Function (anonymous)], // name: 'BTC' // } 为了节省存储空间并避免用户设置错误的代币地址，该库具有编码 encoder 和解码 decoder。 const data = formatsByName['BTC'].decoder('1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa'); console.log(data.toString('hex')); // 76a91462e907b15cbf27d5425399ebf6f0fb50ebb88f1888ac const addr = formatsByCoinType[0].encoder(data); console.log(addr); // 1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa 获取加密货币地址和文本记录 对于加密货币地址和文本记录，必须通过某个币种的键名来获取它的记录值。如果要获取用户已经设置的全部加密货币的地址和文本记录，则必须从事件中检索或者通过 ENS 子图来查询。 例如： { domains(where:{name:\"vitalik.eth\"}) { id name resolver{ texts coinTypes } } } 会返回以下结果： { \"data\": { \"domains\": [ { \"id\": \"0xee6c4522aab0003e8d14cd40a6af439055fd2577951148c14b6cea9a53475835\", \"name\": \"vitalik.eth\", \"resolver\": { \"coinTypes\": [ 60 ], \"texts\": [ \"url\" ] } } ] } } 反向解析 “正向” 解析实现了从名称到地址的映射，而反向解析是指从地址映射回名称。ENS 支持反向解析，以便应用程序用 ENS 名称代替显示十六进制地址。 反向解析是通过专用名称 addr.reverse 和解析器的 name() 函数实现的。 addr.reverse 的所有权属于一个专用的注册器合约，该合约将子名称分配给相应地址的所有者。例如，地址 0x314159265dd8dbb310642f98f50c066173c1259b 可以要求使用 314159265dd8dbb310642f98f50c066173c1259b.addr.reverse ，并设置解析器和解析记录。通过这个解析器的 name() 函数可以取得与该地址关联的名称。 ENS 并不强制要求反向记录的准确性。例如，每个人都可以声明其地址的名称为 “alice.eth” 。所以，为了确保声明是准确的，你必须始终对返回的名称执行正向解析，并检查正向解析得到的地址是否与原始地址匹配。 大多数 ENS 库提供了执行反向解析的功能： 采用 ensjs 时： const address = '0x1234...'; let ensName = null; ({ name: ensName } = await ens.getName(address)) // Check to be sure the reverse record is correct. skip check if the name is null if(ensName == null || address != await ens.name(ensName).getAddress()) { ensName = null; } 采用 web3.js 时： Not supported. 采用 ethjs-ens 时： var address = '0x1234...'; var name = await ens.reverse(address); // Check to be sure the reverse record is correct. if(address != await ens.lookup(name)) { name = null; } 采用 ethers.js 时： var address = '0x1234...'; var name = await provider.lookupAddress(address); // ethers.js automatically checks that the forward resolution matches. 采用 go-ens 时： name, err := ens.ReverseResolve(client, common.HexToAddress(\"0x1234...\") 采用 web3.py 时： address = '0x1234...' name = ns.reverse(address) # Check to be sure the reverse record is correct. if address != ns.address(name): name = None 采用 web3j 时： String address = \"0x1234...\"; String name = ens.reverseResolve(address); // Check to be sure the reverse record is correct. if(address != ens.resolve(name)) { name = null; } 如果不使用库，实现反向解析的过程也是一样的：查询 1234....addr.reverse（其中的 1234... 是需要进行反向解析的地址）的解析器并在该解析器上调用 name() 函数。然后，执行正向解析以验证记录是否准确。 如果您需要处理许多地址（例如：展示交易历史的反向记录），要为每个名称同时设置反向和正向解析是不实际的。我们有一个单独的智能合约叫做 ReverseRecords，它可以让你通过一个函数来查询多个名称。 const namehash = require('eth-ens-namehash'); const allnames = await ReverseRecords.getNames(['0x123','0x124']) const validNames = allnames.filter((n) => namehash.normalize(n) === n ) 为防止同形词攻击，并避免人们仅仅使用大写字母，请确保将返回的名称与规范化名称进行比较。 © Pengfei Ni all right reserved，powered by GitbookUpdated at 2022-05-17 21:05:15 "},"docs/dapp-developer-guide/managing-names.html":{"url":"docs/dapp-developer-guide/managing-names.html","title":"名称管理","keywords":"","body":"转移名称 ENS 中的每个名称都有一个所有者，这个所有者可以是帐户或智能合约，而且是唯一一个可以在 ENS 注册表中对这个名称进行更改的帐户或合约。名称的所有者可以将所有权转移到任何其他帐户或合约。 采用 ensjs 时： await ens.name('alice.eth').setOwner('0x1234...'); 采用 go-ens 时： // opts are go-ethereum's bind.TransactOpts err := registry.SetOwner(opts, \"alice.eth\", common.HexToAddress(\"0x1234...\")) 采用 web3.py 时： ns.setup_owner('alice.eth', '0x1234...') 创建子名称 每个名称的所有者都可以根据需要配置子名称，配置子名称是指创建子名称并将其所有者设置为所需地址的过程，这个地址可以与父名称的所有者相同，也可以不同。 采用 ensjs 时： await ens.name('alice.eth').createSubdomain('iam'); 采用 go-ens 时： // opts are go-ethereum's bind.TransactOpts err := registry.SetSubdomainOwner(opts, \"alice.eth\", \"iam\", common.HexToAddress(\"0x1234...\")) 采用 web3.py 时： ns.setup_owner('iam.alice.eth', '0x1234...') 另外，web3.py 提供了一种便利的方法，可以同时创建子名称、设置解析器和配置地址记录： ns.setup_address('iam.alice.eth', '0x1234...') 一般情况下，名称应该指向所有者的地址，因此上面函数的第二个参数是可选的（默认值是名称所有者的地址）。 设置解析器 在启用新创建的名称或子名称之前，必须设置解析器地址。如果有解析器进行升级并支持了一些你希望用到的功能，你也可以重新设置解析器地址。 名称的解析器通常设置为公共解析器，公共解析器是一个 “符合标准” 的解析器，它能提供常用的功能，但是每个人都可以编写和部署自己的专用解析器，有关详细信息，请参见解析器接口定义。 采用 ensjs 时： await ens.name('iam.alice.eth').setResolver('0x1234'); 在主网和 Kovan 测试网络上，“resolver.eth” 指向了当前部署的最新版本的公共解析器，以便于用户为名称配置并使用公共解析器： const resolver = await ens.resolver('resolver.eth').addr(); await ens.setResolver('iam.alice.eth', resolver, {from: ...}); 采用 go-ens 时： // opts are go-ethereum's bind.TransactOpts err := registry.SetResolver(opts, \"iam.alice.eth\", common.HexToAddress(\"0x1234...\")) 采用 web3.py 时： 不支持自定义解析器。web3.py 会在用户调用 setup_address 时，自动使用公共解析器，它不支持设置自定义解析器。 注意，更改名称的解析器后，该名称在原解析器上的记录不会自动迁移到新解析器上。要更新解析器记录，需要按照下面的程序来实现。 更新解析记录 要更改名称解析到的地址或其他资源，需要更新该名称在其解析器中的记录。 每个解析器都可以指定自己的记录更新机制，但是公共解析器和很多解析器都遵循一套标准的接口。一些 ENS 库提供的解析器记录更新功能就是使用了这类接口。 更新解析到地址的记录 采用 ensjs 时： await ens.name('iam.alice.eth').setAddr('ETH', '0x1234...'); 采用 go-ens 时： resolver, err := ens.NewResolver(client, \"iam.alice.eth\") // opts are go-ethereum's bind.TransactOpts err := resolver.SetAddress(opts, common.HexToAddress(\"0x1234...\")) 采用 web3.js 时： ens.setAddress('iam.alice.eth, '0x1234...', {from: ...}); 采用 web3.py 时： ns.setup_address('iam.alice.eth', '0x1234...') 更新解析到其他资源的记录 有些 ENS 库（目前只有 ensjs 、go-ens 和 web3.js）支持使用相同的模式更新其他记录类型（内容的哈希和文本记录等）。例如，要设置或更新文本记录: 采用 ensjs 时： ens.name('iam.alice.eth').setText('test', 'Test record'); 采用 go-ens 时： // opts are go-ethereum's bind.TransactOpts err := resolver.SetContenthash(opts, []byte{0x12, 0x34...}) err := resolver.SetAbi(opts, \"Sample\", `[{\"constant\":true,\"inputs\":...}]`, big.NewInt(1)) err := resolver.SetText(opts, \"Sample\", `Hello, world`) 采用 web3.js 时： ens.setText('iam.alice.eth', 'Test', 'Test record', {from: ...}); 在一笔交易中更新多条解析记录 公共解析器有一个 multicall 函数，用户可以使用通过该函数在一笔交易中同时更新多条解析记录。详细信息请参阅 公共解析器 部分。 配置反向解析 “常规” 解析实现了从名称到地址的映射，而反向解析是指从地址映射回名称或其他元数据。ENS 支持反向解析，以便应用程序用 ENS 名称代替显示十六进制地址。 要达到上述效果，地址的所有者必须为其地址配置反向解析。配置反向解析通过调用反向解析器上的 claim() 方法来实现，该方法的专用名为 “addr.reverse” 。 配置反向解析通常是通过诸如 ENS APP 这样的用户界面来实现的。 go-ens 和 web3.py 也可以提供这项功能： 采用 go-ens 时： reverseRegistrar, err := ens.NewReverseRegistrar(client) // opts are go-ethereum's bind.TransactOpts err := reverseRegistrar.SetName(opts, \"iam.alice.eth\") 采用 web3.py 时： ns.setup_name('iam.alice.eth', '0x1234...') © Pengfei Ni all right reserved，powered by GitbookUpdated at 2022-05-17 21:04:39 "},"docs/dapp-developer-guide/registering-and-renewing-names.html":{"url":"docs/dapp-developer-guide/registering-and-renewing-names.html","title":"名称注册和续费","keywords":"","body":"如果用户需要注册他的第一个名称，那他必须与注册器进行交互。注册器是一个智能合约，这个合约拥有一个名称的所有权，并在合约中规定了子名称的分发机制。用户想要获得一个名称，就需要向与之对应的注册器申请。例如，用户如果想要一个 .eth 名称，那就必须向 .eth 注册器进行申请。每个注册器都在其内部定义了自己的名称注册 API（以及配套的更新机制）。 目前，还没有能与注册器进行交互的 ENS 库。DApp 需要使用通用的以太坊库（如 web3.js 或 web3.py）与注册器合约进行交互。有关注册器接口的详细信息，请参阅 “合约 API 参考” 部分。 注册器部署 .eth：永久注册器 .test（仅用于测试网）：测试注册器 .addr.reverse：反向注册器 © Pengfei Ni all right reserved，powered by GitbookUpdated at 2022-05-17 21:04:39 "},"docs/dapp-developer-guide/front-end-design-guidelines.html":{"url":"docs/dapp-developer-guide/front-end-design-guidelines.html","title":"ENS 前端设计指南","summary":"ENS 是一个简化用户体验的工具。这里有一系列的使用指南和工具，将帮助你选择合适的设计并实现最佳的 ENS 用户体验。","keywords":"","body":"ENS 是一个简化用户体验的工具。这里有一系列的使用指南和工具，将帮助你选择合适的设计并实现最佳的 ENS 用户体验。 何时显示 ENS 名称 在用户可能看到以太坊地址或内容哈希的每一个实际场景中，都可以换成 ENS 名称显示出来。 关于在 DApp 中向用户显示 ENS 名称，这里有两个典型用例： 用 ENS 名称替换以太坊地址：在供用户浏览和使用的 DApp 的前端界面中，只要是准备显示以太坊地址的位置，你都可以换成 ENS 名称来显示。 解析输入的内容：在那些原本需要输入以太坊地址的文本框里，你可以允许用户直接输入更为易读的 ENS 名称，而不必非要输入一长串十六进制地址。 除了这些用例，还要记得 ENS 公共解析器 支持将 ENS 名称指向 不同类型的资源（比如：在 IPFS 或 Swarm 上存储的内容，或是类似文本内容的任意数据）。因此，还会有一些其他的应用场景会让你想要在 DApp 中使用 ENS。例如，在面对复杂的 IPFS 或 Swarm 内容哈希时，可以使用 ENS 将哈希转换为可读的名称。在 DApp 中启用 ENS 一文可以帮你了解更多关于不同用例的信息。 1. 用 ENS 名称替换以太坊地址 只有当用户为其地址设置了一个 反向记录，并且反向记录（地址 > 名称）能够与 正向解析（名称 > 地址）完全匹配时，这个 ENS 名称（作为对应以太坊地址的替代）才可以被显示出来。 因此，作为 DApp 开发者，首先应该确认用户是否已经为其地址设置了反向记录。而且，由于用户可以自由设置反向记录，即使不属于他的名称或是其他随机字符也可以设置成功，所以，你还应该确认这个反向解析出的名称也能通过正向解析得到原来的地址。请从 这里 和后面的 “其他指南和提示” 部分了解更多内容。 1.1 - 将以太坊地址换成 ENS 名称显示 当用 ENS 名称替换以太坊地址时，你应该考虑以下情况和实践经验: 添加一个可视校验和： 使用 ENS 名称时重要的一点就是得向用户指出，这里的名称是指可以关联以太坊地址或其他哈希的 ENS 名称，而不是指 http 链接。为此，建议将 ENS 名称与某种形式的可视校验和（比如地址的 标识、Blockies 或其他自定义算法表示）相关联。 可视校验和像身份识别一样 可以被欺骗 或模仿，所以它们不能算是一种安全机制。它们只是一个标识符，让用户知道这个名称只是以太坊地址的另一种表示。 设计一个缩略版的 ENS 名称： ENS 名称可以很长，除了不受字符限制之外，用户还可以创建无限数量的子名称以及子名称的子名称，所以可以考虑设计一个缩略版的 ENS 名称。如果显示了缩略版的名称，则应该提供查看完整名称的方法，例如在悬停时展开整个名称。 不是所有的 ENS 名称都以 .eth 结尾： ENS 名称通常以 .eth 结尾。但是，ENS 系统目前已经实现了对 .xyz .luxe .kred .art .club 这几个顶级名称（TLD）的支持，未来还将支持更多的顶级名称。如果你考虑在缩略版的 ENS 名称中显示 TLD 部分，请注意这一点。 1.2 - 提供一个可以随时查看与 ENS 名称关联的以太坊地址的方法 如果要显示 ENS 的完整名称或缩略版，你应该： 始终为用户提供显示完整的以太坊地址的方法： 上面的示例演示了一个弹出选项。还有一个方法是使用提示信息，但是浮动或弹出窗口的方式相比提示信息更为合适，因为前者也具备后者能够实现的特点。 提供一个可以同时查看 ENS 名称及其关联地址的的界面： 相比于弹出窗口只显示地址而隐藏名称的做法，两者同时显示的方式显然对用户更为友好。 允许用户复制完整的以太坊地址： 允许用户通过复制按钮或点选的方式来复制完整地址，而且在这个过程中，显示 ENS 名称的提示信息应该始终保持可见，不会自动关闭。 选择性地为用户提供自动在区块浏览器中打开以太坊地址的方法 ，比如在 Etherscan 浏览器打开（上面示例中的外部链接图标）。 选择性地显示当前登录用户的余额数量。 研究表明，用户不但通过地址本身，还倾向于通过余额来识别自己的以太坊地址。这只适用于当前 “已登录” 的用户：只显示他们自己的余额，同时避免显示其他用户的余额。 1.3 - 同时显示 ENS 名称和以太坊地址 有时你可能希望同时显示 ENS 名称和它解析到的以太坊地址。当遇到下列情况时，这种显示方式就会派上用场： 显示当前连接的用户： 例如，用于标识用户时，可以同时显示 ENS 名称和缩略的以太坊地址。 用户向文本框输入 ENS 名称： 有关内容会在下一节中讨论输入文本解析时进行更详细的描述。 在其他高风险情况下： 当用户想要证实某个用户或地址是谁时，或者你注意到用户为了在弹出窗口中查看以太坊地址而持续点击 ENS 名称时，你就可以用同时显示名称和地址的方式代替只有名称的显示方式。 2. 输入文本解析 在用户可以输入以太坊地址的文本框里也应该支持 ENS 名称的输入和解析，这些输入表明用户希望与另一个用户的以太坊地址或合约进行交互。 通过遵循以下准则，可以建立最好的用户体验: 在解析 ENS 名称之前稍作等待： 等待用户输完最后的 TLD（比如 .eth 、.xyz 或 .luxe），或者是在用户停止输入后等待 0.2-1 秒的时间，然后再解析输入的名称（要避免出现 急于解析的问题）。 不要用以太坊地址覆盖输入的字段： 应该在输入字段附近显示解析后的 ENS 名称。 始终同时显示 ENS 名称和以太坊地址： 在成功实现该功能后再执行此操作，而且最好是根据准则 1.1 中的建议添加可视校验和。 其他指南和提示 如果反向记录和正向解析不能正确对应时该怎么办 如前所述，用户可以将 反向解析记录 设置为任何内容，甚至是另一个用户拥有的名称或者完全随机的字符串。这就是为什么在查询了写在反向记录中的名称之后，DApp 开发者还应该检查它是否匹配正向解析，因为正向解析标明了 ENS 名称指向的地址。 如果两者不匹配，就不能显示可读的名称，只能直接显示以太坊地址。 否则，用户可能会在你的 DApp 中冒充其他用户。 关于反向解析的章节中含有用于此类验证的 代码。 关于用户名的显示 最为直接的方式是将用户的 ENS 名称作为用户名显示。为此，可以让用户在你的子名称下注册一个名称，或者使用反向解析查找用户的 ENS 名称。 缓存和更新 ENS 名称 如果你的 DApp 需要在 UI 界面中显示许多以太坊地址或 ENS 名称，你还可以考虑在解析（和验证）该名称后，或是用户在输入字段中添加该名称之后，将这个 ENS 名称缓存起来。 你的开放式 UI 可以在毫无风险的情况下安全地显示缓存中的名称，例如，用户只是在浏览，并且不需要根据显示的信息采取行动或做出决策，尤其是有风险的决策。 但是，在所有存在危险的情况下（如转移 ETH 、代币或其他值），或者当用户与另一个 ENS 名称或以太坊地址交互时，你就应该直接执行实时解析，并从 ENS 注册表中获取最新的信息。 此外，考虑到用户可以随时更改ENS注册表中的信息，你还应该定期验证当前缓存的信息。为此，你可以订阅相关合约中发生的一些特定事件，尤其是 AddrChanged 和 NameChanged。 关于显示以太坊地址的说明（无论有没有 ENS 名称） 研究表明，即使在 ENS 名称未启用的情况下，在 DApps 中显示以太坊地址时也有一些好的经验可以借鉴。 始终以 “0x” 开头，以表明它是一个地址。 需要缩略显示名称时，可以显示地址的前 4 个和后 4 个字符。相对来说，缩略地址更容易被欺骗，所以这并不是一个安全要求，但这是一个很好的经验，因为有些用户检查名称的开头，有些用户检查名称的结尾。而且，我们的大脑可以轻松划分、解析和记忆的字符最多为 4 个。 始终提供一种显示完整以太坊地址的方式。可以采用与显示 ENS 名称或提示信息相同的弹出组件。 前面提到的一些经验也适用于缩略的以太坊地址： 允许用户复制完整的以太坊地址（就像前面说到的一样，提示信息可能不是一个好方法）。 选择性地为用户提供自动在区块浏览器中打开以太坊地址的方法。 前端工具 Aragon-UI - Address Badge组件（Design Files / 代码） Decentraland-UI - 地址提示工具（非 ENS 专用） © Pengfei Ni all right reserved，powered by GitbookUpdated at 2022-05-17 21:05:15 "},"docs/dapp-developer-guide/ens-as-nft.html":{"url":"docs/dapp-developer-guide/ens-as-nft.html","title":"ENS 作为一种 NFT","keywords":"","body":"自从 ENS 的 .eth 注册器在 2019 年 5 月完成迁移后，.eth 注册器已经成为一个符合 ERC721 标准的 NFT（非同质化代币）合约，这意味着 .eth 名称可以像其他 NFT 那样进行转移。 从 ENS 名称派生 tokenId ENS 名称的 tokenId 其实是以 uint256 形式来表示名称标签的哈希值（比如，名称 vitalik.eth 的标签是 vitalik）。 const ethers = require('ethers') const BigNumber = ethers.BigNumber const utils = ethers.utils const name = 'vitalik' const labelHash = utils.keccak256(utils.toUtf8Bytes('vitalik')) const tokenId = BigNumber.from(labelHash).toString() 在上面的示例中，79233663829379634837589865448569342784712482819484549289560981379859480642508 就是名称 vitalik.eth 的 tokenId。 从 tokenId 派生 ENS 名称 与派生 tokenId 不同，从 tokenId 派生 ENS 名称并不容易。这是因为所有 ENS 名称都存储为固定长度的哈希，以便允许注册长度不限的名称。这种架构的缺点是不能使用 tokenId 直接查询 ENS 智能合约来返回 ENS 名称。 我们推荐的方式是通过 TheGraph 服务 中的 ENS 子图来查询。TheGraph 可以通过其索引将哈希值解码为名称。查询的示例代码如下。 const ethers = require('ethers') const BigNumber = ethers.BigNumber const gr = require('graphql-request') const { request, gql } = gr const tokenId = '79233663829379634837589865448569342784712482819484549289560981379859480642508' // Should return 0xaf2caa1c2ca1d027f1ac823b529d0a67cd144264b2789fa2ea4d63a67c7103cc const labelHash = BigNumber.from(tokenId).toHexString() const url = 'https://api.thegraph.com/subgraphs/name/ensdomains/ens' const GET_LABEL_NAME = gql` query{ domains(first:1, where:{labelhash:\"${labelHash}\"}){ labelName } }` request(url, GET_LABEL_NAME).then((data) => console.log(data)) // { domains: [ { labelName: 'vitalik' } ] } 如果你不喜欢依赖 TheGraph 这样的第三方，开源的 ENS-rainbow 包含了原始数据集（6GB，内含 1.33 亿条数据）的链接，这样你就可以托管自己的 ENS 解码服务。 将子名称转换为 NFT 目前，所有的子名称或非 .eth 名称都不是 NFT（比如 dcl.eth 和 .kred ），除非名称注册器本身支持 NFT 标准。如果你想将自己所有的子名称转换成 NFT，你必须创建一个注册器： 创建一个符合 ERC721 标准的注册器合约 设置 ENS 注册表地址（主要是在部署注册器时） 创建 register 函数用来调用 registry.setSubnodeOwner，然后通过将子域标签哈希转换为 tokenId 来生成 NFT。 contract DCLRegistrar is ERC721Full, Ownable { constructor( IENSRegistry _registry, ) public ERC721Full(\"DCL Registrar\", \"DCLENS\") { // ENS registry updateRegistry(_registry); } function register( string memory _subdomain, bytes32 subdomainLabelHash, address _beneficiary, uint256 _createdDate ) internal { // Create new subdomain and assign the _beneficiary as the owner registry.setSubnodeOwner(domainNameHash, subdomainLabelHash, _beneficiary); // Mint an ERC721 token with the suddomain label hash as its id _mint(_beneficiary, uint256(subdomainLabelHash)); } } 一旦部署完成，您就必须将控制器地址转移到该合约。 对于非技术用户，我们目前正在升级我们的 SubdomainRegistrar，它能让你不用写代码也可以将你的子名称变成 NFT。 元数据（Metadata） .eth does not have .tokenURI . However, we created a separate metadata service which NFT marketlpaces like OpenSea can fetch metadata for ENS such as registration data, expiration date, name length, etc. For more detail, please refer to the metadata documentation site. .eth 没有 .tokenURI。然而，我们创建了一个独立的元数据服务，OpenSea 等 NFT 市场 可以获取 ENS 的元数据，如注册数据、过期时间、名称长度等。要了解更多细节，请参考元数据文档。 © Pengfei Ni all right reserved，powered by GitbookUpdated at 2022-05-17 21:04:39 "},"docs/dapp-developer-guide/ens-l2-offchain.html":{"url":"docs/dapp-developer-guide/ens-l2-offchain.html","title":"L2 和链下数据支持","keywords":"","body":"重要提示 ENS 链外数据支持的开发仍在进行中，下面描述的解决方案还没有在生产环境中使用。因此，本文主要是为了提供信息而编写的，以便 dapp 和钱包开发人员在完全支持集成后可以为集成做准备。 摘要 随着以太坊 L2 解决方案的普及，以太坊开始走向成熟，重要的是 ENS 能够在整个生态系统中提供解析服务，并使 ENS 用户能够享受 L2 解决方案所带来的效率。在 Vitalik 的一篇文章提出了一种可能的方法之后，ENS 团队以及 ENS 和 L2 社区一直在构建一个通用的“ L2 桥”，它能为 ENS 和其他应用程序提供跨平台的互操作性并提出标准，这些应用程序需要以零信任的方式从各种链下数据源 (存储在以太坊主网之外的任何数据，这包括专有数据库和 L2 解决方案，如 Optimism、Arbitrum、Starkware、ZKSync 等等) 来获取数据。 EIP-3668: CCIP Read: 安全地获取链外数据 ENSIP 10: 通配符解析 EIP 3668 允许以一种对客户透明的方式进行链下 (包括 L2 ) 数据查询，并可以让合约的作者实现任何必要的验证。在许多情况下，如果数据存储在链上，则无需任何额外的信任假设。 ENSIP 10 是在 L1 上解析通配符 (如: *.foo.eth) 的通用方法。通过分发子名称并将父名称的解析移至链下，可以让 dapp 在链下创建子名称，然后通过 L1 访问。 Dapp 和钱包支持链下数据查询所需的步骤 如果你的 dapp 或钱包使用了下面的库，EIP 3668 和 ENSIP 10 支持将被内置，所以只要在准备好时更新库即可。 ethersjs web3js ethersjs 目前，EIP 3668 是作为 npm 模块实现的: @chainlink/ethers-ccip-read-provider (source). 基本的用法示例如下。 import { CCIPReadProvider } from '@chainlink/ethers-ccip-read-provider'; import { abi as IExtendedResolver_abi } from '@ensdomains/offchain-resolver-contracts/artifacts/contracts/IExtendedResolver.sol/IExtendedResolver.json'; const IExtendedResolver = new ethers.utils.Interface(IExtendedResolver_abi); const baseProvider = ethers.getDefaultProvider(options.provider); const provider = new CCIPReadProvider(baseProvider); 目前还不支持通配符。 详情请参考链下解析器客户端示例代码。 web3js 开发中。 其他库 如果您使用其他库或自定义集成，请向项目仓库提出 github issue，如果项目对应的仓库不存在，请到 ENS 项目管理仓库 提出 issue，以便 ENS 团队跟踪进展。 Dapp 和钱包分发子名称的步骤 如果您希望使用链下数据存储发布子名称，请参考链下解析器。该示例使用平面文件作为数据源，但可以轻易地替换为数据库调用。 L2 的支持仍然在开发中。 常见问题 更改是向后兼容的吗? 是的。即使在没有客户端或应用程序支持这些标准的情况下，L1 上现有的名称也可以正常使用。只有在 L1 之外的名称才不会被解析。 GraphQL 支持 L2 或链下数据吗? 一旦某个 L2 得到官方支持，我们将需要为这个 L2 桥编制一个子图，并且我们会通过模式拼接让调用者可以透明地使用它们。 对于没有托管在受支持的 L2 上的名称，我们将无法获取那些通常只在子图上可用的数据。 如何支持其他 EVM 兼容链? 非 L2 链缺乏以零信任方式验证 L1 上数据的方法。替代办法是，跨链桥的运营者作为可信的第三方，托管链下网关，或者由 dapp 托管自己的网关，并使用 ENS 名称的私钥对每条数据进行签名。 我能在链下环境中发布新的 tld 吗? 不能。详细信息请看 为什么 ENS 不创建更多的顶级域：我们在对全球名称空间负责。 我可以在链下名称中设置一个主名称吗? 可以。然而，反向注册器 (它是一个以 .addr.reverse 开头的隐藏的顶级名称) 目前存储在 L1 上，所以需要在 L1 上消耗 Gas。我们将来可能会考虑将反向注册器迁移至 L2。 我可以在链下注册 .eth 名称吗? 当发现哪个 L2 对 ENS 集成的支持最友好以后，我们会将 .eth 名称迁移到特定的 L2，这会是迁移的最后一步，只有这些完成以后，才可以实现 .eth 名称的链下注册。 我如何处理合约地址? 与 EOA (外部帐户) 不同，多签账户等基于合约的帐户可能只能在某些链中访问。 ENSIP-11 允许单个名称在多个 EVM 兼容链中保存不同的地址，建议将合约地址存储到 EVM 链指定地址记录字段。 我可以使用其他支持 .eth 名称服务的库吗? @unstoppabledomains/resolution 对 ENS 的支持)已于 2021 年 12 月移除。其他服务往往不支持所有 ENS tld，尤其是基于 DNS 的 tld (.com .net 等)，所以我们建议不要依赖这些库解析 ENS 名称。 参考文献和以前的讨论 MVP of ENS on L2 with Optimism: Demo Video + How to Try It Yourself A general-purpose bridge for Ethereum Layer 2s A general-purpose L2-friendly ENS standard Video: ENS Workshop on 18th Oct 2021 Video: ENS Workshop on 6th April 2021 Video: ENS on Layer 2 meeting #2 on 28th Oct 2020 Video: ENS on Layer 2 meeting on 13th Oct 2020 Video: ENS workshop on 29th Sep 2020 © Pengfei Ni all right reserved，powered by GitbookUpdated at 2022-05-17 21:04:39 "},"docs/contract-api-reference/ENS-Contracts-Overview.html":{"url":"docs/contract-api-reference/ENS-Contracts-Overview.html","title":"ENS 合约概述","keywords":"","body":"ENS是一个由多个合约组成的系统。这种模块化的特性允许随着时间的推移而构建(或删除)功能。尽管一切都依赖于简单且稳定的 ENS 注册表，但其他模块的逐步添加、升级和更迭，反映了 ENS 不断演变的生态系统。 这个分布图可以分为两部分: ENS 协议和 ENS DAO。 ENS 协议 该系统的核心是ENS注册表，它已部署在所有以太坊测试链上（并使用一个允许它部署在任何其他 EVM 兼容链上的脚本），并且可以在所有链上的指定地址 0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e 上找到。这是一个相对简单的合约：根节点的所有者可以为不同的子节点创建所有者。然后，这些所有者可以为节点设置解析器，或与其他所有者一起创建其他子节点。 在以太坊主网上，根节点的所有者（可以在注册表内查询 id 为 0x0 的节点获得）是根管理合约。以下是主要节点及其相关合约的所有者： 根管理 (root.ens.eth) 这是根域的简单访问控制。它作为 ENS 注册表的接口，同时也支持锁定某些名称。一旦锁定，所有者就无法解锁。在撰写本文时，只有 .eth 被锁定了，而且由于此合约不允许转移根节点本身的所有权，这意味着 .eth 注册器现在主注册表中被永久性锁定。根合约的所有者被设置为 multisig.ens.eth。 多签 (multisig.ens.eth) 这是一个由 7 名钥匙持有者组成的小组，他们最初负责管理 ENS 的主要内容。随着 ENS DAO 的推出，这些责任中的大部分正在慢慢转移，但按照 EP1 的要求，根所有权仍然属于他们。 .ETH 注册器 (registrar.ens.eth) 这是一份与 ERC721 兼容的合约，是 ENS 用户将其作为 NFT 而添加到钱包中的地址。转移 NFT 不会自动更新注册表上的所有权，但允许 NFT 所有者调用 \"claim()\" 函数，该函数将代表他们更新注册表。该合约允许其所有者 (当前设置为 DAO) 添加和删除控制器，以及更改注册器的所有权。NFT 的元数据不在合约中设置，而是存储在 metadata.ens.domains 服务中。 DNS 注册器 (dnsregistrar.ens.eth) 本合约拥有 ICANN 认可的大多数 TLD，并使用 DNSSec 更新这些名称。 DNS 预言机 (dnssec.ens.eth) 此预言机对给定的 DNS 名称执行 CCIP 读取，并授予所有者权限。要了解更多信息，请阅读链外数据安全检索标准 反向注册器 (addr.reverse) 此反向注册器允许帐户设置其主要名称。 解析器 解析器是存储与地址或子节点对应的元数据的合约，如 ETH 或 BTC 地址。用户可以将其设置为任何合约。最新的公共解析器位于 resolver.ens.eth，但是还有很多其他的解析器可以使用。 ENS DAO ENS DAO (wallet.ensdao.eth)：这是 DAO 的主合约，以及持有资金的地址。它目前作为根域、代币、注册器、控制器和 dns 注册器的所有者。这是一份 Open Zepellin Governor 合约，它可以通过代币投票的方式接受提案。所有提案都有 48 分钟的延迟。DAO 没有为设置管理角色，这意味着主管和延迟属性不能再更改。它有权向注册器添加和删除控制器，并从控制器中提取资金。 *主管 (governor.ensdao.eth)：本合约负责计算投票，如果多数票超过预设人数，就会为 DAO 发出交易。 *代币 (token.ensdao.eth)：这是兼容 ERC20 的代币合约。它还包含空投和投票代表的代码。该合约允许其所有者 (DAO) 每年进行一次最高不超过总供应量 2% 的增发。 注册控制器 注册控制器负责注册新名称，并延长名称的有效期。可以添加多个控制器。注册和续期的费用是交给这个合约的。 价格预言机 此合约检查预言机中的以太价格，以计算续费的以太价格。DAO 可以将其逻辑更改为任何内容，但任何歧视特定用户的功能都将违反 ENS 章程第一条。 代币发放 (tokenlock.ensdao.eth) 在撰写本文时，本合约持有代币供应量的 65%，并逐渐向核心开发代币的受益人发放空投 (包括 DAO 本身)。 © Pengfei Ni all right reserved，powered by GitbookUpdated at 2022-05-17 21:04:39 "},"docs/contract-api-reference/name-processing.html":{"url":"docs/contract-api-reference/name-processing.html","title":"名称处理","summary":"描述如何规范化 ENS 名称以及如何将名称进行哈希.","keywords":"","body":"ENS 只使用固定长度的256位加密哈希来代替可读的名称。为了从名称派生哈希的同时仍然保留其层次性，使用了名为 Namehash 的算法。例如，“alice.eth” 的 Namehash 为 0x787192fc5378cc32aa956ddfdedbf26b24e8d78e40109add0eea2c1a012c3dec ，这是名称在 ENS 内部的唯一表示方式。 在使用 Namehash 进行哈希之前，首先使用 UTS-46 标准对名称进行规范化，确保名称中的字母与大小写无关，并禁止使用无效字符。任何对名称进行哈希和解析的操作都必须首先对其进行规范化，以确保所有用户获得 ENS 的一致性。 规范化名称 在使用 Namehash 将名称转换为哈希节点之前，必须首先对名称进行规范化和有效性检查（比如将 fOO.eth 规范为 foo.eth）并屏蔽包含下划线等禁止字符的名称。更为关键的是，所有应用程序都必须遵循相同的规范化和验证规则集，否则相同的字符输入到不同系统上可能会被解析为两个不同的 ENS 名称。 使用ENS和处理可读名称的应用程序在进行规范化和验证时必须遵循 UTS46 。处理过程应该通过设置 UseSTD3ASCIIRules=true 采用非过渡规则。 eth-ens-namehash 这个 Javascript 库会执行这里描述的规范化和哈希。DApp 开发者指南中涉及的所有 ENS 库 都会执行规范化和哈希。 对名称进行哈希 Namehash 是一个递归过程，可以为任何有效的名称生成唯一的哈希。从任意一个名称的 Namehash 开始（比如 “alice.eth” 的 Namehash）可以推导出任意子名称的 Namehash（比如 “iam.alice.eth” 的 Namehash），而且推导过程中不需要知道或处理 “alice.eth” 这个可读的原始名称。正是这个特性使得 ENS 能够成为一个层次性的系统，且不必在内部处理可读的文本字符串。 术语 名称（domain）- ENS 标识符的完整且可读的形式，比如 iam.alice.eth 。 标签（label）- 名称的独立组成部分 - 比如：iam ，alice 或 eth 。 标签哈希（label hash）- 单个标签经过 keccak256 函数计算后的输出值，比如：keccak256(‘eth’) = 0x4f5b812789fc606be1b3b16908db13fc7a9adf7ca72641f84d75b47069d3d7f0 节点（node）- namehash 函数的输出值，用作 ENS 名称的唯一性标识。 算法 首先，按点（“.”）分隔将名称划分为标签。所以，“vitalik.wallet.eth” 变成了列表[“vitalik”, “wallet”, “eth”]。 然后按递归的方式定义 namehash 函数如下： namehash([]) = 0x0000000000000000000000000000000000000000000000000000000000000000 namehash([label, …]) = keccak256(namehash(…), keccak256(label)) 下面是用 Python 实现 namehash 的示例。 def namehash(name): if name == '': return '\\0' * 32 else: label, _, remainder = name.partition('.') return sha3(namehash(remainder) + sha3(label)) Namehash 在 EIP137 中有详细的说明。 如何查询一个名称的标签哈希或 namehash 在某些情况下，你可能需要知道特定 ENS 名称的哈希值。labelhash 表示名称标签的哈希值（例如：makoto 是 makoto.eth 的标签)， namehash 是标签哈希组合后的哈希值。我们目前正在努力将这些信息呈现在我们的管理应用程序（即 ENS App）。同时，您可以通过 TheGraph 中的 ENS 子图 利用以下代码查询相关信息。 { domains(where: {name:\"vitalik.eth\"}) { id name labelName labelhash } } 不明确名称的处理 由于 unicode 中有大量的字符，而且所表示的脚本种类繁多，因此不可避免地会出现不同的 unicode 字符，这些字符在常用字体中是相似的，甚至是相同的。这一点可能会被用来欺骗用户，让用户以为他们正在访问某个站点或资源，而实际上他们正在访问是另一个站点或资源。即所谓的 “同形攻击” 。 向用户显示名称的客户端和其他软件应该针对这些攻击采取对策，比如突出显示有问题的字符，或者向用户显示混合脚本的警告。Chromium 的 IDN 策略 对于呈现 IDN 名称时的客户端行为具备一定的参考价值。 © Pengfei Ni all right reserved，powered by GitbookUpdated at 2022-05-17 21:04:39 "},"docs/contract-api-reference/ens.html":{"url":"docs/contract-api-reference/ens.html","title":"注册表","summary":"ENS 注册表。","keywords":"","body":"源代码 ENS 注册表是 ENS 系统中的核心合约，所有的 ENS 查询都从注册表开始。注册表负责管理名称列表，记录每个名称的所有者、解析器和 TTL ，并允许名称的所有者对这些数据进行更改。 ENS 注册表的详细信息请参阅 EIP137 。 获取所有者 function owner(bytes32 node) external view returns (address); 以上函数返回 node 所标识名称的所有者。 获取解析器 function resolver(bytes32 node) external view returns (address); 以上函数返回 node 所标识名称的解析器地址。 获取 TTL function ttl(bytes32 node) external view returns (uint64); 以上函数返回 node 所标识名称的缓存存活时间（TTL）。希望缓存名称信息(包括所有者、解析器地址和其他记录)的系统应该重视这个值。如果 TTL 为 0 ，那么每次查询都需要获取新数据。 设置所有者 function setOwner(bytes32 node, address owner) external; 将 node 所标识名称的所有权重新分配给 owner ，此函数只能由名称当前的所有者调用。 该操作会触发以下事件： event Transfer(bytes32 indexed node, address owner); 设置解析器 function setResolver(bytes32 node, address resolver) external; 将与 node 所标识名称相关联的解析器更新为 resolver ，此函数只能由名称当前的所有者调用。resolver 必须是一个实现了解析器接口的合约地址。 该操作会触发以下事件： event NewResolver(bytes32 indexed node, address resolver); 设置 TTL function setTTL(bytes32 node, uint64 ttl) external; 更新 node 所标识名称的缓存存活时间，此函数只能由名称当前的所有者调用。 该操作会触发以下事件： event NewTTL(bytes32 indexed node, uint64 ttl); 设置子名称所有者 function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external; 创建一个新的子名称 node ，将其所有权分配给指定的 owner 。如果该子名称已经存在，则重新分配所有权，但解析器和 TTL 保持不变。 label 是要创建的子名称标签的 keccak256 哈希。例如，如果你拥有 alice.eth 并想创建子名称 iam.alice.eth ，就需要将 namehash('alice.eth') 作为 node ，将 keccak256('iam') 作为 label 。 该操作会触发以下事件： event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner); 设置名称记录 function setRecord(bytes32 node, address owner, address resolver, uint64 ttl); 通过一次操作在 ENS 记录中设置名称的所有者、解析器和 TTL 。这个函数是为了方便用户操作而提供的，调用这个函数完全等同于按一定的顺序调用 setResolver setTTL 和 setOwner 。 设置子名称记录 function setSubnodeRecord(bytes32 node, bytes32 label, address owner, address resolver, uint64 ttl); 设置子名称的所有者、解析器和 TTL ，并在必要时创建这个子名称。这个函数是为了方便用户操作而提供的，它能够先将子名称的全部三个字段设置好之后，再在将子名称的所有权转移给调用者。 设置授权 function setApprovalForAll(address operator, bool approved); 设置或取消授权。得到授权的帐户可以代表该函数调用者执行所有关于 ENS 注册表的操作。 检查授权 function isApprovedForAll(address owner, address operator) external view returns (bool); 如果 operator 被授权代表 owner 进行 ENS 注册表的操作，则返回 true 。 检查记录是否存在 function recordExists(bytes32 node) public view returns (bool); 如果 node 存在于 ENS 注册表中，则返回 true 。对于存在于旧 ENS 注册表中且尚未迁移到新注册表的记录，将返回 false 。 © Pengfei Ni all right reserved，powered by GitbookUpdated at 2022-05-17 21:04:39 "},"docs/contract-api-reference/reverseregistrar.html":{"url":"docs/contract-api-reference/reverseregistrar.html","title":"反向注册器","summary":"反向注册器负责通过 .addr.reverse 这一专用 TLD 进行反向解析的管理。","keywords":"","body":"源代码 ENS 中的反向解析是指从以太坊地址（比如 0x1234...）到 ENS 名称的映射，它通过一个特定的名称空间（.addr.reverse）来实现。这个名称空间由一个专用注册器拥有和控制，该注册器可以接受任何人的调用，并根据调用者的地址为其分配子名称。 例如，账户 0x314159265dd8dbb310642f98f50c066173c1259b 可以通过调用声明 314159265dd8dbb310642f98f50c066173c1259b.addr.reverse. ，然后为其配置一个解析器并指定元数据（比如此地址的规范 ENS 名称）。 反向注册器提供了声明反向记录的函数，同时为了提供一种给地址指定规范名称的方式，反向注册器还内置了一个便于配置最常用记录的函数。 反向注册器的详细信息请参阅 EIP181。 声明地址 function claim(address owner) public returns (bytes32); 通过在反向注册器中声明调用者的地址，将反向记录的所有权分配给 owner ，相当于调用 claimWithResolver(owner, 0) 。 通过解析器声明地址 function claimWithResolver(address owner, address resolver) public returns (bytes32) 通过在反向注册器中声明调用者的地址，将反向记录的所有权分配给 owner ，如果 resolver 非 0 ，则会同时更新这个反向记录的解析器。 调用该函数之后： 调用者的反向记录（1234....addr.reverse）归 owner 所有。 如果 resolver 非 0 ，调用者的反向记录中的解析器将被设置为 resolver ；如果 resolver 为 0 ，解析器将保持不变。 设置名称 function setName(string memory name) public returns (bytes32) 将调用者的反向 ENS 记录设置为给定的 name 。 通常用户只想配置反向名称而无需配置其他内容，而这个函数通过简化设置反向记录的过程，方便了用户。它按以下步骤执行: 为调用者设置反向记录，这个反向记录的所有者是反向注册器。 将调用者反向记录中的解析器设置为 defaultResolver 。 将调用者反向记录中 defaultResolver 的 name() 字段设置为 name 。 简而言之，在调用此方法之后，用户的反向记录会有一个完整的配置，反向记录中该账户的规范名称被设置为给定的 name 。 想要进行灵活配置的用户需要使用 claim 或 claimWithResolver ，并在他们选定的解析器合约上手动配置记录。 获取反向记录节点 function node(address addr) public pure returns (bytes32) 此函数通过接收地址并返回该地址的反向记录的节点（namehash 输出），方便了想要查询地址元数据的合约，并避免再使用那些需要处理十六进制编码和哈希以获得所需值的合约。 获取默认解析器 Resolver public defaultResolver; 返回 反向注册器 用于 setName 的解析器合约的地址。 © Pengfei Ni all right reserved，powered by GitbookUpdated at 2022-05-17 21:04:39 "},"docs/contract-api-reference/testregistrar.html":{"url":"docs/contract-api-reference/testregistrar.html","title":"测试注册器","keywords":"","body":"源代码 通过测试注册器可以方便地在以太坊测试网络上测试 ENS 。测试注册器通常部署在 .test TLD 上，它允许用户即时注册一个用于测试目的的名称，该名称在注册 28 天后自动过期。 注册一个名称 function register(bytes32 label, address owner) public; 注册一个其 keccak256 哈希等于 label 的子名称，并将其所有者设置为 owner 。例如，注册 myname.test ，就用 keccak256('myname') 作为第一个参数调用 register 函数。 注册有效期为 28 天。 获取过期时间 mapping (bytes32 => uint) public expiryTimes; 返回指定子名称到期的 unix 时间戳。例如，调用 expiryTimes(keccak256('myname')) 可以检查 myname.test 的过期时间。 © Pengfei Ni all right reserved，powered by GitbookUpdated at 2022-05-17 21:04:39 "},"docs/contract-api-reference/publicresolver.html":{"url":"docs/contract-api-reference/publicresolver.html","title":"公共解析器","summary":"默认的公共解析器。","keywords":"","body":"源代码 公共解析器是一个通用的 ENS 解析器，它适用于大多数标准的 ENS 用例。名称的所有者可以使用公共解析器更新相应的 ENS 记录。 公共解析器遵循以下 EIP 提案: EIP137 - Contract address interface ( addr() ). EIP165- Interface Detection ( supportsInterface() ). EIP181 - Reverse resolution ( name() ). EIP205 - ABI support ( ABI() ). EIP619 - SECP256k1 public keys ( pubkey() ). EIP634 - Text news ( text() ). EIP1577 - Content hash support ( contenthash() ). 虽然公共解析器是一个方便的默认解析器，但仍然存在许多其他的解析器实例和版本。调用者不能假设名称使用的是公共解析器的最新版本，或是解析器包含了这里描述的所有方法。要检查一个解析器是否支持某个特性，请参见 接口检查支持 。 接口检查支持 function supportsInterface(bytes4 interfaceID) external pure returns (bool) ENS 使用 ERC165 进行接口检测。ERC165 要求支持它的合约实现一个名为 supportsInterface 的函数，该函数接收一个接口 ID 并返回一个布尔值，这个布尔值表示是否支持该接口。 接口 ID 由包含在接口中的每个函数的 4 字节函数 ID 通过异或计算而来。例如，addr(bytes32) 的函数 ID 为 0x3b3b57de ，因为它是以太坊地址接口中唯一的函数，所以它的接口 ID 也是 0x3b3b57de ，因此调用 supportsInterface(0x3b3b57de) 将为任何支持 addr() 的解析器返回 true 。 ERC165 的接口 ID 为 0x01ffc9a7 ，因此 supportsInterface(0x01ffc9a7) 对于任何支持 ERC165 的合约（也就是对于任何解析器）都将返回 true。 注意，公共解析器不公开设置属性值函数的显式接口，因此对于指定的设置属性值函数，目前没有办法对其进行自动检查。 获取以太坊地址 function addr(bytes32 node) external view returns (address) 返回与给定的 node 关联的以太坊地址，如果没有则返回 0 。 这个函数的接口 ID 为 0x3b3b57de 。 这个函数的详细信息请参阅 EIP137 。 设置以太坊地址 function setAddr(bytes32 node, address addr) external; 将与给定的 node 关联的以太坊地址设置为 addr 。 只能由 node 的所有者调用。 该操作会触发以下事件： event AddrChanged(bytes32 indexed node, address a); 获取区块链地址 function addr(bytes32 node, uint coinType) external view returns(bytes memory); 根据传入参数 node 和 coinType 返回相应区块链的地址，如果没有，则返回 0 。 这个函数的接口 ID 为 0xf1cb7e06 。 这个函数的详细信息请参阅 EIP 2304 。 返回值是加密货币地址的原生二进制格式，而且每种区块链地址都有不同的编码和解码方式。 例如，比特币地址 1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa 按照 base58check 算法解码为 21 字节的 0062e907b15cbf27d5425399ebf6f0fb50ebb88f18 ，再通过 scriptPubkey 算法转换为 25 字节的 76a91462e907b15cbf27d5425399ebf6f0fb50ebb88f1888ac ；而 BNB 地址 bnb1grpf0955h0ykzq3ar5nmum7y6gdfl6lxfn46h2 按照 Bech32 算法转换为二进制表示得到 40c2979694bbc961023d1d27be6fc4d21a9febe6 。 要将二进制表示转换为地址，请使用 address-encoder（地址编码器）的 formatsByCoinType[SYMBOL].encoder(binary) 方法。 如果 coinType 在指定节点 node 上不存在，则返回零长度的字符串。 设置区块链地址 function setAddr(bytes32 node, uint coinType, bytes calldata addr) external; 将与 node 和 coinType 相应的区块链地址设置为 addr 。 coinType 是加密货币类型索引，它由 SLIP44 定义。 要将地址转换为二进制表示，请使用 address-encoder（地址编码器）的 formatsByCoinType[SYMBOL].encoder(binary) 方法。 只能由 node 的所有者调用。 该操作会触发以下事件： event AddressChanged(bytes32 indexed node, uint coinType, bytes newAddress); 获取规范名称 function name(bytes32 node) external view returns (string memory); 返回与给定的 node 关联的规范 ENS 名称，专门用于反向解析。 这个函数的接口 ID 为 0x691f3431 。 这个函数的详细信息请参阅 EIP181 。 设置规范名称 function setName(bytes32 node, string calldata name) external; 为给定的 node 设置规范 ENS 名称 name 。 只能由 node 的所有者调用。 该操作会触发以下事件： event NameChanged(bytes32 indexed node, string name); 获取内容哈希 function contenthash(bytes32 node) external view returns (bytes memory); 返回 node 的内容哈希（如果存在的话）。涉及的值会被格式化为机器可读的 multicodecs ，详细信息请参阅 EIP1577 。 contenthash 用于存储 IPFS 和 Swarm 内容哈希，可以将 ENS 名称解析到托管在这些分布式网络上的内容（如网站）。 这个函数的接口 ID 为 0xbc1c58d1 。 这个函数的详细信息请参阅 EIP1577 。 设置内容哈希 function setContenthash(bytes32 node, bytes calldata hash) external; 将给定 node 的内容哈希设置为 hash 。 只能由 node 的所有者调用。 涉及的值会被格式化为机器可读的 multicodecs ，详细信息请参阅 EIP1577 。 该操作会触发以下事件： event ContenthashChanged(bytes32 indexed node, bytes hash); 获取合约 ABI ABI(bytes32 node, uint256 contentTypes) external view returns (uint256, bytes memory); 返回与给定 node 匹配的 ABI 定义（如果存在的话）。contentTypes 是调用者可以接受的二进制编码。如果指定了多个内容类型，解析器将选择一个返回。目前支持的内容类型有： 内容类型 ID 描述 1 JSON 2 zlib 压缩的 JSON 4 CBOR 8 URI ABI 返回内容类型 ID 和 ABI 数据的二元组。如果没有找到合适的内容类型 ID 的数据，则内容类型 ID 返回 0，ABI 数据将是空字符串。 这个函数的接口 ID 为 0x2203ab56 。 这个函数的详细信息请参阅 EIP205 。 设置合约 ABI function setABI(bytes32 node, uint256 contentType, bytes calldata data) external 为 node 设置或更新 ABI 数据。contentType 是给定的内容类型 ID ，而且必须给定一个类型 ID ；data 包含经过编码的 ABI 数据。如果要清除名称的 ABI 数据，请将 data 设置为空字符串。 只能由 node 的所有者调用。 该操作会触发以下事件： event ABIChanged(bytes32 indexed node, uint256 indexed contentType); 获取公钥 function pubkey(bytes32 node) external view returns (bytes32 x, bytes32 y) 以二元组 (x, y) 的形式返回 node 的 ECDSA SECP256k1 公钥。如果没有设置公钥，则返回 (0, 0) 。 这个函数的接口 ID 为 0xc8690233 。 这个函数的详细信息请参阅 EIP619 。 设置公钥 function setPubkey(bytes32 node, bytes32 x, bytes32 y) external 将 node 的 ECDSA SECP256k1 公钥设置为 (x, y) 。 只能由 node 的所有者调用。 该操作会触发以下事件： event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y); 获取文本数据 function text(bytes32 node, string calldata key) external view returns (string memory) 检索 node 的文本元数据。每个名称可能有多个元数据片段，每个片段由一个唯一的键值 key 标识。如果 node 中由键值 key 标识的文本数据不存在，则返回空字符串。 key 可选的标准值有： 键值 含义 email 电子邮箱地址 url 网址（URL） avatar 用作头像或标识的图像的网址 description 名称的描述信息 notice 关于名称的通知 keywords 逗号分隔的关键字列表，按重要性由高到低排列，与此字段有交互的客户端可以通过设置一个阈值来选择忽略哪些内容 此外，任何人都可以指定特定于服务提供商的键值，这些键值必须以 com. 作为前缀。目前已知的特定于服务提供商的键值如下: 键值 含义 com.twitter Twitter 标识符 com.github Github 标识符 这个函数的接口 ID 为 0x59d1d43c 。 这个函数的详细信息请参阅 EIP634 。 设置文本数据 function setText(bytes32 node, string calldata key, string calldata value) external 将 node 中由唯一键值 key 标识的文本元数据设置为 value ，同时会覆盖掉之前 node 中由 key 标识存储的所有内容。如果要清除文本字段，请将其设置为空字符串。 只能由 node 的所有者调用。 该操作会触发以下事件： event TextChanged(bytes32 indexed node, string indexedKey, string key); 多重调用 function multicall(bytes[] calldata data) external returns(bytes[] memory results) 允许用户在一次操作中设置多条记录。 使用 encodeABI 函数对合约调用进行编码，并将其传递给 data。 前端使用情况如下: var addrSet = resolver.contract.methods['setAddr(bytes32,address)'](node, accounts[1]).encodeABI(); var textSet = resolver.contract.methods.setText(node, \"url\", \"https://ethereum.org/\").encodeABI(); var tx = await resolver.multicall([addrSet, textSet], {from: accounts[0]}); © Pengfei Ni all right reserved，powered by GitbookUpdated at 2022-05-17 21:05:15 "},"docs/contract-api-reference/eth-permanent-registrar/readme.html":{"url":"docs/contract-api-reference/eth-permanent-registrar/readme.html","title":".eth 永久注册器","keywords":"","body":"永久注册器是负责顶级名称 .eth 的分配和更新的智能合约。 系统架构 永久注册器的代码可以在 ethregistrar 仓库中找到。 注册器本身称为基本注册器（BaseRegistrar）。该合约实现了以下几个关键功能: 注册器的所有者可增减 “控制器（controller）”。 控制器可以注册新名称和延长现有名称的有效期，但不能更改现有名称的所有权或缩短其过期时间。 名称所有者可以将所有权转移到另一个地址。 如果名称所有者丢失了所有权，他们可以在 ENS 注册表中收回所有权。 在 1 年过渡期内，原注册器的名称所有者可将其迁移至新版注册器。迁移名称时，他们的押金将全部退还给他们。 此外，注册器是一个符合 ERC721 标准的非同质化代币（NFT）合约，也就是说 .eth 的名称可以像其他 NFT 一样被转移。 用户在转移名称所有权，或在 ENS 名称注册表恢复所有权时（例如，一个名称的所有权以前被转移到一个合约中），将直接与此合约进行交互。用户还可以通过名称查询来查看其注册状态和到期日期。对于初始注册和续费，用户需要与控制器合约进行交互。 这种关注点分离的方式减少了注册器受到的攻击，并在注册器存在的情况下为用户的名称所有权提供了保证。另外，它还规定了注册和续费机制的改进和创新。将来的更新中可能会将根名称和 .eth 顶级名称的所有权转移到一个受限权限的合约中，从而防止根密钥持有者干预 .eth 的注册，同时不影响控制器的持续更新。 最初部署的控制器叫 ETHRegistrarController ，该控制器给长度为7个及更多字符的名称提供了一个简单的注册和续费机制，实现了以下功能: 控制器的所有者可以设定价格预言机合约，该合约根据名称及其注册或续费的时长来确定注册和续费的价格。 控制器的所有者可将已收取的全部款项取回到他的账户。 用户可以通过 “请求-注册” 的过程注册新名称，并支付适当的注册费。 用户可以通过支付适当的资金来续费名称，而且对于某个名称，除了名称所有者，其他用户也可以为这个名称续费。另外，续费的时长也没有限制。 由于任何人都可以为某个名称续费，如果一个用户非常关注某个与其交互的名称的有效期，那他可以在必要时通过自己付费来确保该名称保持注册状态。 由于可以进行任意时长的续费，用户可以 “锁定” 理想的注册费（译注：这里的理想主要是针对以太币来说的，因为续费价格只是相对美元稳定，而相对以太币则不确定）。通过长时间的续费，可以实现名称的 \"长期有效\"，保证了由智能合约所保障的名称稳定性。 起初，将部署一个独立的定价预言机合约，即 StablePriceOracle 。该合约的所有者能够以美元为单位分别给不同长度的名称设定价格，并使用 USD:ETH 价格预言机按照当前汇率将该价格转换成以太币（Ether）。用户注册某个名称时不必直接与这个预言机交互，因为确定该名称注册或续费价格的功能已经内置在了控制器合约里。 发现 找到新版注册器的地址很容易：在 ENS 注册表中通过调用 owner(namehash('eth')) 来查询 “eth” 名称的所有者。 为了支持发现控制器的地址，ENS 通过 EIP1844 支持接口发现。该机制允许通过以下过程来查询实现了所需接口的合约地址： 设置 node = namehash('eth')。 通过调用 ENS 注册表上的 resolver(node) 来查找 ENS 解析器。 调用该解析器上的 interfaceImplementer(node, interfaceId) 方法，其中 interfaceId 是你所需接口的 EIP165 接口 ID 。 以下是目前为 .eth 永久注册器定义的接口 ID ： 0x6ccb2df4 ，ERC721（NFT）的接口 ID ，它返回注册器本身的地址（也可以通过地址查找或查找 “.eth” 的所有者来获取）。 0x018fac06 ，控制器的接口 ID ，返回控制器的地址。 0x7ba18ba1 ，旧版注册器的迁移功能的接口 ID ，返回旧版注册器地址。 © Pengfei Ni all right reserved，powered by GitbookUpdated at 2022-05-17 21:04:39 "},"docs/contract-api-reference/eth-permanent-registrar/registrar.html":{"url":"docs/contract-api-reference/eth-permanent-registrar/registrar.html","title":".eth 永久注册器的实现","keywords":"","body":"源代码 本合约实现了永久注册器的核心功能，具有以下特点： 注册器的所有者可添加或移除 “控制器（controller）”。 控制器可以注册新名称和延长现有名称的有效期（即为名称续费），但不能更改现有名称的所有权或缩短其过期时间。 名称所有者可以将所有权转让给另一个地址。 如果名称所有者丢失了所有权，他们可以收回在 ENS 注册表中记录的所有权。（译注：看到这句是不是有点蒙圈？这是因为 ENS 中名称的所有权可以分为两种，很容易混淆，官方团队未来会统一这些术语。） 在 1 年过渡期内，旧版注册器的名称所有者可将其迁移至新版注册器。迁移名称时，会退还全部押金。 本节要讲的是注册器接口的各个部分，这些内容与那些编写注册器交互工具的开发者紧密相关。为简洁起见，省略了注册器所有者或控制器特有的功能。 注册器只处理标签哈希，确切地说是标签的第一个组件的 keccak256 值（比如，对 ens.eth 来说就是 keccak256('ens')）。为了与 ERC721 兼容，这些值表示为 uint256 值，而非 bytes32 值，但是它们之间可以相互转换。通过计算 keccak256(baseNode, labelHash) 可以获得名称的namehash，其中的 baseNode 是注册器所管理的 TLD 的 namehash ，比如 namehash('eth') 。 注册和续费是通过注册器的 控制器 来处理的。 名称和注册 ENS 中的每个名称都有一个所有者，名称所有者可以将名称转让给新所有者、设置解析器、创建和重新分配子名称，这些功能都包含在 ENS 注册表中。 直接在 .eth 下分配的名称（例如，以 .eth 结尾的二级名称，如 alice.eth）是由前面所说 .eth 永久注册器管理的。当从注册器购买一个名称并合法获取该名称在 ENS 中的所有权时，注册器会自动跟踪谁拥有注册，即谁是注册人，这里的注册人在 .eth 永久注册器里是唯一的。（译注：这里提到的 “注册” 是个名词，可以理解为 “注册证书” ，注册证书代表了一个名称的 “主权” ，拥有这个注册证书的人就是这个名称的 “注册人” ，而注册人具有最高操作权限，可以收回名称的所有权。简而言之，注册人是一个名称的真正主人，而我们经常提到的所有者其实是这个名称的管理者。下面我们还会多次提到 “注册”，切记它是一个名词，为方便理解，不妨将其自行脑补为 “注册证书” 。） 名称的注册人可以将注册转让给另一个帐户（译注：即名称过户），也可以通过调用 reclaim 来恢复名称的所有权，该方法将 ENS 名称的所有者重置为注册人的帐户。 将名称的所有权和注册的所有权进行分离，是为了易于构建对 ENS 进行自动更新的系统。注册人可以将名称的所有权转让给其他帐户或是一个用于管理记录、子名称等信息的智能合约，同时仍然保留着恢复所有权的能力，以便于进行版本升级或回退等操作。 当涉及所有权时，很重要的一点是要弄清楚你是在考虑名称的所有权还是注册的所有权。 读取操作 获取名称到期时间 function nameExpires(uint256 label) external view returns(uint); 返回当前名称到期的 unix 时间戳，未注册的名称或是尚未从旧版注册器迁移的名称将返回 0 。 检查名称的可用性 function available(uint256 label) public view returns(bool); 如果名称可以注册，则返回 true 。考虑到旧版注册器上那些尚未迁移的已注册名称，注册控制器可能会对名称注册增加一些超出注册器合约的限制条件（例如，最小名称长度），所以该函数不应该用于检查用户是否可以注册某个名称。要检查用户是否可以注册某个名称，应该 通过控制器检查名称的可用性。 获取迁移截止时间 uint public transferPeriodEnds; transferPeriodEnds 记录着一个 unix 的迁移截止时间戳，这个时间到达后，就不能再从旧版注册器进行注册迁移，且所有未迁移注册的名称都可以被重新注册。 获取控制器状态 mapping(address=>bool) public controllers; controllers 允许调用者检查某个地址是否被授权为注册控制器。 检查名称授权 function getApproved(uint256 tokenId) public view returns (address operator); 返回该名称的许可操作员的地址。（译注：如果不理解这里的 “许可” ，请查阅有关以太坊 approve 操作的信息。） 这个函数是 ERC721 的一部分。 检查所有名称授权 function isApprovedForAll(address owner, address operator) public view returns (bool); 如果 operator 得到了可以转让 owner 的所有名称的授权，则返回 true 。 这个函数是 ERC721 的一部分。 获取名称所有者 function ownerOf(uint256 label) external view returns(address); ownerOf 返回由标签的哈希标识的注册的所有者的地址（译注：即返回注册人的地址），如果注册不存在则返回 0 。尚未从旧版注册器迁移的注册会被视为不存在的注册。 这个函数是 ERC721 的一部分。 写入操作 转让名称 function transferFrom(address from, address to, uint256 tokenId) public; function safeTransferFrom(address from, address to, uint256 tokenId) public; function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public; 以上函数转让的是注册（译注：即变更注册人）。 它们按照 ERC721 中的规定来执行。 实现一次成功转让会触发以下事件： event Transfer(address indexed from, address indexed to, uint256 indexed tokenId); 许可操作 function approve(address to, uint256 tokenId) public; function setApprovalForAll(address operator, bool _approved) public; ERC721 中记录了这些用于许可管理的函数的信息。 收回 ENS 所有权 function reclaim(uint256 label) external; 将 ENS 注册表中名称所有者的记录设置为该名称注册的所有者，该函数只能由注册的所有者调用。 事件 名称迁移事件 event NameMigrated(uint256 indexed hash, address indexed owner, uint expires); 当名称从旧版注册器迁出时，会触发此事件。 名称注册事件 event NameRegistered(uint256 indexed hash, address indexed owner, uint expires); 当一个控制器注册一个新名称时会触发此事件。 名称续费事件 event NameRenewed(uint256 indexed hash, uint expires); 当一个控制器给一个名称续费（或注册）时会触发此事件。 转让事件 event Transfer(address indexed from, address indexed to, uint256 indexed tokenId); 将注册转移到新所有者时会触发此事件。这与 ENS 注册表 的转让事件不同，后者记录的是 ENS 的所有权转移。 © Pengfei Ni all right reserved，powered by GitbookUpdated at 2022-05-17 21:04:39 "},"docs/contract-api-reference/eth-permanent-registrar/controller.html":{"url":"docs/contract-api-reference/eth-permanent-registrar/controller.html","title":".eth 永久注册器的控制器","keywords":"","body":"源代码 本节要讲的是 .eth 注册控制器（ETHRegistrarController）的各个部分，这些内容与那些编写注册控制器交互工具的开发者息息相关。为简洁起见，省略了注册器所有者特有的功能。 控制器只与明文标签一起工作（例如，“alice” 代表 “alice.eth”）。 为了防止名称抢注，.eth 注册控制器需要对新名称注册（但不需要对续费）执行一个 “请求-注册” 的过程。要注册一个名称，用户必须： 利用待注册名称和一个秘密值生成一个固定长度的哈希。 将第 1 步中生成的定长哈希提交给控制器。 等待至少 1 分钟，但别超过 24 小时。 将这个名称的注册请求以及来自第 1 步的秘密值一起提交。 这个过程保证了注册不会被抢注，除非攻击者能够审查至少 1 分钟前用户请求注册名称的交易。 示例 名称注册 下面的示例演示了注册名称所需的步骤。 采用 web3.js 时： const controller = web3.eth.contract(controller_abi).at(controller_address); async function register(name, owner, duration) { // Generate a random value to mask our commitment const random = new Uint8Array(32); crypto.getRandomValues(random); const salt = \"0x\" + Array.from(random).map(b => b.toString(16).padStart(2, \"0\")).join(\"\"); // Submit our commitment to the smart contract const commitment = await controller.makeCommitment(name, owner, salt); const tx = await controller.commit(commitment); // Add 10% to account for price fluctuation; the difference is refunded. const price = (await controller.rentPrice(name, duration)) * 1.1; // Wait 60 seconds before registering setTimeout(async () => { // Submit our registration request await controller.register(name, owner, duration, salt, {value: price}); }, 60000); } 为简明起见，这个例子是使用异步而不是用回调编写的。因此，这个例子可以在 web3 的 1.0.x 版本下正常工作。注意，它不会在 MetaMask 内置的 web3 中工作，因为这是一个较老的版本，缺乏异步支持。 读取操作 获取最短请求时间 uint constant public MIN_COMMITMENT_AGE; 这个公共常量表示请求的最短时间（以秒为单位），一次请求只能在它被打包后至少经过这么多秒才能正式注册。 DApps 应该获取这个常量，而不是对当前值进行硬编码，因为这个常量可能会在以后的升级中发生变化。 获取最长请求时间 uint constant public MAX_COMMITMENT_AGE; 这个公共常量表示请求的最长时间（以秒为单位），一个请求在它被打包后经过这么多秒之后就会失效，不能再用于注册名称。 DApps 应该获取这个常量，而不是对当前值进行硬编码，因为这个常量可能会在以后的升级中发生变化。 获取最短注册时间 uint constant public MIN_REGISTRATION_DURATION; 这个公共常量表示注册的最短持续时间(以秒为单位)，少于此期限的注册将被拒绝。 DApps 应该获取这个常量，而不是对当前值进行硬编码，因为这个常量可能会在以后的升级中发生变化。 获取请求时间戳 mapping(bytes32=>uint) public commitments; commitments 存储了从每一份提交的请求到对应请求时间戳的映射。在提交注册交易之前，希望验证请求有效性的调用者应该先检查这个映射。 获取租金价格 function rentPrice(string name, uint duration) view public returns(uint); rentPrice 按照参数中提供的名称和时长，在几秒钟内返回注册或续费所需的资金（以 wei 为单位）。调用者应该注意到这个价格可能随着时间的推移而变化，特别是价格预言机依赖一种法币来进行定价的时候。 调用者应该使用这个函数来获取注册费用并显示给用户，而不是在应用程序内部计算这些费用，因为以后对价格预言机的变更或升级可能会产生不同的定价方案，而且每年的注册费用取决于名称长度、注册持续时间或其他变量。 检查名称的有效性 function valid(string name) public view returns(bool); 如果这个名称符合该控制器对注册的有效性要求（比如它满足长度要求），则 valid 返回 true 。 检查名称的可用性 function available(string name) public view returns(bool); 如果这个名称符合该控制器对注册的有效性要求，并且可以注册，则 available 返回true。在这个函数内部，使用了（上面的）valid 函数和 注册器 合约中的 available 函数，available 函数同时检查名称在旧版 ENS 注册器和当前 ENS 注册器中的可用性。 调用者应该使用这个函数来检查名称是否可以注册，而不要用注册器合约中的 available 函数，后者不检查名称的长度。 计算请求哈希 function makeCommitment(string name, address owner, bytes32 secret) pure public returns(bytes32); makeCommitment 从名称标签（比如 “myname” ，而不是 “myname.eth”）和秘密值生成并返回一个请求哈希。 写入操作 提交请求 function commit(bytes32 commitment) public; commit 用于提交预请求，这个预请求调用了 makeCommitment 生成的请求哈希。 注册名称 function register(string name, address owner, uint duration, bytes32 secret) public payable; register 用于注册名称，有效的注册请求必须符合下列准则: available(name) == true duration >= MIN_REGISTRATION_DURATION secret 用于判定一个有效的请求（例如，commitments[makeCommitment(name, secret)]）存在，并且在 1 分钟到 24 小时之间 msg.value >= rentPrice(name, duration) 由于租金价格可能会随时间变化，所以建议调用者发送的租金略高于rentPrice返回的价格，5-10%的溢价应该就足够了，多余的资金都会返还给调用者。 调用成功会触发以下事件： event NameRegistered(string name, bytes32 indexed label, address indexed owner, uint cost, uint expires); 调用成功还会连带注册器触发一个 名称注册事件，并连带 ENS 注册表触发一个 NewOwner 事件。 延长名称有效期 function renew(string name, uint duration) external payable; renew 用于给一个名称续费，将该名称的有效期延长 duration 指定的秒数。只要提供足够的资金，任何人都可以调用这个函数。由于租金价格可能会随时间变化，所以建议调用者发送的租金略高于 rentPrice 返回的价格，5-10% 的溢价应该就足够了，多余的资金都会返还给调用者。 调用成功会触发以下事件： event NameRenewed(string name, bytes32 indexed label, uint cost, uint expires); 调用成功还会连带注册器触发一个 名称续费事件。 © Pengfei Ni all right reserved，powered by GitbookUpdated at 2022-05-17 21:05:15 "},"docs/contract-api-reference/dns-registrar.html":{"url":"docs/contract-api-reference/dns-registrar.html","title":"DNS 注册器","keywords":"","body":"在 ENS 上，有两个关于 DNS 的智能合约，DNSSECOracle 和 DNSRegistrar。 DNSSEC（名称系统安全扩展）建立了一个信任链，从 ICANN 签名的根密钥（.）向下至每个密钥。我们首先知道 DNS 根密钥的哈希值（这是在 oracle 智能合约中硬编码的）。有了该密钥的哈希值，就可以传入实际的密钥，验证它是否与此哈希值匹配，验证后我们可以将它添加到可信记录集。 有了该密钥，我们现在可以验证任何用该密钥签名的记录，在本例中，它是 xyz 顶级域的根哈希值。这样，我们就能识别密钥，等等。 任何人都可以在以太坊区块链上向 DNSSEC oracle 提交经过 DNSSEC 签名的 DNS 记录的证明，只要是采用当前支持的公钥方案和摘要签名的就行。如果一个人能够通过 DNSSEC Oracle 证明他拥有某个 DNS 域名的所有权，那么 DNSRegistrar 会将相应的 ENS 名称分配给他。 DNSRegistrar 的地址 Mainnet: 待定 Ropsten: 0x475e527d54b91b0b011DA573C69Ac54B2eC269ea 注册 ENS 名称时，可以通过查找其上级名称所有者（例如 .matoken.eth 的上级名称是 .eth）来查找注册器合约地址。但是，当您通过DNSSEC 注册器进行注册时，如果您是在该 TLD下 第一个注册的，那么父名称可能不存在。 Gas 消耗 向 DNSSEC Oracle 提交证明涉及复杂的计算过程，因此会消耗大量 Gas。如果你是在某个 TLD 下第一个提交名称的，还会消耗更多的 Gas，因为它在同时提交您的名称及其父名称这两项证明（例如：matoken.live 与 .live）。在 Ropsten 网络上进行测试时，此过程消耗了 1,663,953 gas。 Typescript/Javascript 库 To help you interact with DNSSEC data and the DNSRegistrar, we provide two libraries. 为了帮助您与 DNSSEC 数据以及 DNSRegistrar 进行交互，我们提供了两个库。 DNSProvejs：用于从 DNS 查询和验证 DNSSEC 数据的库 dnssecoraclejs：为 ENS DNSSEC Oracle 生成证明数据的一个库。 示例 从 DNS 中检索证明 import { Oracle } from '@ensdomains/dnssecoraclejs' import { DNSProver } from '@ensdomains/dnsprovejs' const textDomain = '_ens.matoken.xyz' const prover = DNSProver.create(\"https://cloudflare-dns.com/dns-query\") const result = await prover.queryWithProof('TXT', textDomain) 检索 DNS 文本记录 const result = { answer: SignedSet { records: [{ name: '_ens.matoken.xyz', type: 'TXT', ttl: 300, class: 'IN', flush: false, data: [Array] }], signature: { name: '_ens.matoken.xyz', type: 'RRSIG', ttl: 300, class: 'IN', flush: false, data: [Object] } }, proofs: [ SignedSet { records: [Array], signature: [Object] }, SignedSet { records: [Array], signature: [Object] }, SignedSet { records: [Array], signature: [Object] }, SignedSet { records: [Array], signature: [Object] }, SignedSet { records: [Array], signature: [Object] } ] } // Retrieving the text record result.answer.records[0].data.toString() // 'a=0xa5313060f9fa6b607ac8ca8728a851166c9f612' queryWithProof 返回 answer 和 proofs。answer 包含 DNS 记录的可读记录及其签名（RRSIG）。上面的例子显示了区块链上的一条数据（返回的第一个记录），这条数据包含着一条 a=$ETHEREUM_ADDRESS 格式的 TXT 记录。 向 DNSRegistrar 提交证明 import { Oracle } from '@ensdomains/dnssecoraclejs' import { abi } from '@ensdomains/contracts/abis/dnsregistrar/DNSRegistrar.json' import { Contract } from 'ethers' // The registrar address nees to be hard-coded const registrarAddress = '0x475e527d54b91b0b011DA573C69Ac54B2eC269ea' const registrar new Contract(registrarAddress, abi, provider) const oracleAddress = await registrar.oracle() const oracle = new Oracle(oracleAddress, provider) const { data, proof } = oracle.getProofData(result) if(data.length === 0){ // This happens if someone has submitted the proof directly to DNSSECOracle, hence only claim a name on the registrar. return registrar.claim(claim.encodedName, proof) }else{ // This submits proof to DNSSECOracle, then claim a name. return registrar.proveAndClaim(claim.encodedName, data, proof) } 下一步 目前缺少一个 Typescript/JS 库，这个库支持通过提供 NSEC/NSEC3（下一代安全记录）证明来删除 DNSSECOracle 中的记录。 © Pengfei Ni all right reserved，powered by GitbookUpdated at 2022-05-17 21:04:39 "},"docs/contract-developer-guide/resolving-names-on-chain.html":{"url":"docs/contract-developer-guide/resolving-names-on-chain.html","title":"链上名称解析","keywords":"","body":"目前还没有用于链上解析的可靠库，但是 ENS 解析非常简单，不需要库也可以轻松完成。首先，我们定义了一些只包含必要方法的简化接口，: abstract contract ENS { function resolver(bytes32 node) public virtual view returns (Resolver); } abstract contract Resolver { function addr(bytes32 node) public virtual view returns (address); } 解析时，在 ENS 合约中只需要用到 resolver 函数。ENS 合约中的其他方法可以用来在拥有名称的合约中查找所有者和更新 ENS 名称。 根据这些定义，查询一个给定节点哈希的名称非常简单： contract MyContract { // Same address for Mainet, Ropsten, Rinkerby, Gorli and other networks; ENS ens = ENS(0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e); function MyContract(address ensAddress) public { ens = ENS(ensAddress); } function resolve(bytes32 node) public view returns(address) { Resolver resolver = ens.resolver(node) return resolver.addr(node); } } 虽然合约可以将可读名称转换成节点哈希，但考虑到处理节点哈希会更加便利和高效，我们强烈建议在合约中使用节点哈希来取代名称，同时将规范化名称这项复杂工作交给链下的调用者来执行。如果某个合约总是解析一些相同的名称，则可以将这些名称转换为节点哈希并作为常量存储在合约中。 © Pengfei Ni all right reserved，powered by GitbookUpdated at 2022-05-17 21:04:39 "},"docs/contract-developer-guide/writing-a-resolver.html":{"url":"docs/contract-developer-guide/writing-a-resolver.html","title":"编写一个解析器","keywords":"","body":"EIP137 中描述了解析器的详细信息。一个解析器必须实现以下方法： function supportsInterface(bytes4 interfaceID) constant returns (bool); supportsInterface 在 EIP165 中定义，它可以被调用者用来确定一个解析器是否支持某个特定的记录类型。记录类型是指解析器必须一起实现的一个或多个方法的集合。当前定义的记录类型包括: 记录类型 函数 接口 ID 定义文档 以太坊地址 addr 0x3b3b57de EIP137 ENS 名称 name 0x691f3431 EIP181 ABI 规范 ABI 0x2203ab56 EIP205 公钥 pubkey 0xc8690233 EIP619 文本记录 text 0x59d1d43c EIP634 内容哈希 contenthash 0xbc1c58d1 supportsInterface 本身的接口 ID 为 0x01ffc9a7 ，当 interfaceID 值为 0x01ffc9a7 时，supportsInterface 也必须返回 true 。 此外，content 接口被用作 Swarm 哈希事实上的标准，它的接口 ID 为 0xd8389dc5 。现在新的内容哈希应该使用 contenthash 接口来实现。 解析器示例 一个只支持 addr 类型的简易解析器，看起来就像这样: contract SimpleResolver { function supportsInterface(bytes4 interfaceID) constant returns (bool) { return interfaceID == 0x3b3b57de; } function addr(bytes32 nodeID) constant returns (address) { return address(this); } } 这个简易解析器总是返回自己的地址作为所有查询的结果。尽管解析器采用不同的机制应该返回相同的结果，但实际上解析器可以按照需要采用任何机制来确定返回的结果，并且应该尽可能降低 gas 费用。 © Pengfei Ni all right reserved，powered by GitbookUpdated at 2022-05-17 21:04:39 "},"docs/contract-developer-guide/writing-a-registrar.html":{"url":"docs/contract-developer-guide/writing-a-registrar.html","title":"编写一个注册器","keywords":"","body":"ENS 中的注册器就是一个拥有某个名称所有权的合约，并根据合约代码中定义的一组规则来分配它的子名称。一个简易的即时注册合约如下: contract FIFSRegistrar { ENS ens; bytes32 rootNode; function FIFSRegistrar(address ensAddr, bytes32 node) { ens = ENS(ensAddr); rootNode = node; } function register(bytes32 subnode, address owner) { var node = sha3(rootNode, subnode); var currentOwner = ens.owner(node); if (currentOwner != 0 && currentOwner != msg.sender) throw; ens.setSubnodeOwner(rootNode, subnode, owner); } } 你可能希望通过设置自定义规则为用户分配新名称，至于设置什么样的规则，这完全由你来决定。 你还应该记住，只要你保留父名称的所有权（无论是直接的还是通过另一个合约的方式），你的用户就无法保证他们拥有的子名称的所有权不会被你收回，也无法保证他们关于子名称的设置不会被你更改。你可能打算将名称的所有权转让给一个能够限制你控制它的合约中。有关示例，请参见 ENSNow。 © Pengfei Ni all right reserved，powered by GitbookUpdated at 2022-05-17 21:04:39 "},"docs/ens-migration-february-2020/guide-for-dapp-developers.html":{"url":"docs/ens-migration-february-2020/guide-for-dapp-developers.html","title":"DApp 开发者迁移指南","keywords":"","body":"如果您维护着一个依赖于 ENS 的 DApp、钱包或库，为了确保在迁移期间和之后不会对您的用户造成干扰，您需要完成一些工作。这个文档描述了你需要做什么来更新你的应用程序。 需要做什么 实现名称解析的 DApp、钱包和库 您应该尽快将代码中的 ENS 注册表地址更改为新地址：0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e 。这个新地址现在已经启用，它会返回与旧地址相同的结果。为确保您的用户不会经历任何服务的干扰或中断，最好现在就更改。 如果您在 2 月 3 日迁移过程开始时，仍然没有更新注册地址，您的用户就会逐渐看到过期的信息：迁移以后注册或更新的名称不能被正确解析。 如果您维护着一个库，您应该发布一个新版本，其中包含更新的地址，并通知用户尽快更新。在用户无法轻松升级到最新版本的情况下，您可以考虑通过发布 “猴子补丁” 的方式说明地址的更换。 主网和所有测试网的 ENS 现在都部署在相同的地址上。 实现名称注册或更新的 DApp、钱包和库 如果您的 DApp 或库允许用户注册名称，或更改当前名称，您有两种选择： 只需尽快切换到新的注册表地址。切换之后，用户将暂时不能在你的应用程序中设置他们的名称，直到用户的名称在 2 月 3 日至 5 日之间的某个时间完成迁移。 进行名称设置时，请在新注册表上调用 recordExists 函数。如果返回 true ，就将名称设置的交易发送到新注册表，否则就把它发送到旧注册表。如果您选择这么做，您仍然应该禁止转让 .eth 这种 ERC721 代币，因为在名称迁移时发生的转让交易可能会使用户感到疑惑。 迁移过程会自动将 .eth 二级名称（例如 foo.eth）转移到新注册表和新注册器。子名称（例如 bar.foo.eth）和其他种类名称（例如 foo.xyz）需要由它们的所有者进行迁移。有关该过程的更多细节，请参阅此次迁移的 技术说明，或向 ENS 团队寻求帮助。 ENS 二级市场 如果你经营着一个 ENS 名称交易市场，应该立即停止交易。虽然这个漏洞目前还没有被利用，可一旦它的存在被公开，我们预计攻击者会逆向检查并利用它。停止当前 ENS 注册器的交易可以防止您的用户受到影响。 在名称完成迁移之后，旧注册器 0xfac7bea255a6990f749363002136af6556b31e04 上的 ERC721 代币不再与ENS名称对应，并且毫无价值，因此，您必须最迟在 2 月 3 日 00:00 UTC 之前停止这些交易。 您可以立即启用新注册器上的名称交易，地址为 0x57f1887a8BF19b14fC0dF6Fd9B2acc9Af147eA85 。当名称从 2 月 3 日 00:00 UTC 开始迁移到这个合约时，名称的所有者将自动在这个新注册器上创建新的 ERC721 代币，其 ID 与当前注册器中的相同。 © Pengfei Ni all right reserved，powered by GitbookUpdated at 2022-05-17 21:04:39 "},"docs/ens-migration-february-2020/technical-description.html":{"url":"docs/ens-migration-february-2020/technical-description.html","title":"技术说明","keywords":"","body":"最近，我们注意到 ENS 注册表合约存在一个漏洞。这个漏洞导致名称的所有者可以设置 “后门”，通过这个后门，他们可以在将一个名称转让或出售给别人以后，还能单方面收回该名称的所有权。 这个漏洞有个特点：攻击者必须先拥有该名称的合法所有权，并且必须在转让名称所有权之前设置这个 “后门”。因此，该漏洞不能被用来追回名称。 这个漏洞是由 Sam Sun 通过以太坊基金会的漏洞悬赏程序报告的。我们已经详细检查了 ENS 的注册表，并且确信之前没有人利用过这个漏洞。因此，所有 ENS 名称的所有权都是安全的。 因此，ENS 将迁移到一个新部署的合约上。本文档描述了具体的技术操作步骤，并简要描述这些操作对 DApp 开发者和用户的影响。 本文所描述的内容主要是针对那些对迁移的底层细节感兴趣的人，而对于大多数用户或开发者来说，则没有必要了解这些内容。对于漏洞及其对用户影响的描述，可以参阅 这篇文章 ；对于迁移步骤的描述，开发者们可以参阅 DApp 开发者迁移指南。 新部署的 ENS 合约 大多数 ENS 合约已经重新部署完成。其中有几个进行了更改，还有一些正在重新部署，确保它们引用的是新注册表。 ENS 注册表 新版的 ENS 注册表已经成功部署在这个地址：0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e 。除了修复漏洞，我们还利用这个机会实现了一些其他的功能，这些功能会提高 ENS 的可用性： 添加了 setRecord 和 setSubnodeRecord 方法，允许在单个操作中设置所有者、解析器和 TTL 。 增加了基于 ERC721 的审批机制，允许用户将名称的控制权委托给另一个地址，而无须转让名称。 新注册表合约已经由 Sam Sun 进行了审查，并经过了 ConsenSys Diligence 的复查，双方都没有发现问题。 为了使迁移尽可能地顺利，我们给新注册表配置了回调机制。如果它在自己的存储中查询不到某条记录，它会在以前的 ENS 注册表合约中查询。此回调仅对读操作有效；如果旧注册表中存在记录，而新注册表中还没有，则用户不能调用函数来修改新注册表中的记录。 这意味着要将所有名称从以前的注册表中迁移过来，必须像从零开始一样重新创建名称。例如，如果 foo.eth 在新注册表中还不存在，那么 eth 的所有者必须通过调用 setSubnodeOwner（或新的 setSubnodeRecord）将其作为新名称进行创建。其他顶级名称的所有者（例如，.luxe .kred .club 和 .art）需要代表其用户执行此操作，以便这些用户能够恢复对其名称的写权限。 因此，如果某条记录没有迁移到新注册表，用户和应用程序可以继续更新旧注册表中的记录，然后这些变化最终将映射至新注册表中。在将记录迁移到新注册表以后，在旧注册表中进行的更改就不会再映射到新注册表中。这可以确保由智能合约操作的名称继续发挥作用，直到它们的所有者采取手动操作将它们迁移过来。 下面列出了针对各种类别名称的迁移策略： 顶级名称（.eth .luxe .kred .club .art .xyz 和 .reverse）的迁移作为部署工作的一部分来完成。 .eth 二级名称（如 foo.eth）将会自动为用户进行迁移，详细信息请参阅下面的 “迁移合约” 部分。 由子名称注册器管理的子名称也会自动为用户迁移。 通过其他方式创建的子名称需要父名称的所有者通过调用 setSubnodeOwner 或 setSubnodeRecord 来重新创建。ENS APP 为用户直接拥有的子名称提供一键迁移的功能。 反向解析记录（.addr.reverse 名称）需要在 ENS APP 界面中通过 “claim” 过程来重新创建。 .xyz 记录的迁移需要先在 ENS APP 界面通过 “claim” 过程证明相应 DNS 域名的所有权。 .kred .art 和 .club 名称由这些顶级名称的操作人员迁移。 对于尚未迁移到新注册表的名称，名称解析可以正常进行。用户只有在更改名称的所有权、解析器或 TTL 时，才需要关心迁移的问题。 .eth 注册器 新版的 .eth 注册器（BaseRegistrarImplementation）也已经重新部署，地址是：0x57f1887a8BF19b14fC0dF6Fd9B2acc9Af147eA85 。这个注册器基本没有变化，只进行了一些细微的修改，以便于支持迁移。 迁移合约 一个专门为迁移过程而设计的新合约已经部署在这个地址：0x6109DD117AA5486605FC85e040ab00163a75c662 。该合约作为新版 .eth 注册控制器，在迁移过程开始时，会在旧注册器中被设置为 .eth 的所有者。该合约内实现的功能可以将 .eth 二级名称（如 foo.eth）从旧注册表和旧注册器迁移到新版本中。 一旦激活，ENS 团队将会把所有当前注册的 .eth 二级名称迁移到新部署的合约系统中。所有名称的注册记录将自动转到新注册器，名称有效期保持不变。注册表记录将被自动迁移，除非它们受到合约的控制。那些由合约控制的名称不会自动迁移，这样做是为了避免破坏注册器合约。 如果你的某个名称是由智能合约控制的（例如，使用了自定义注册器来分配子名称），那么你需要部署一个新版本的合约，并引用新注册表，然后自己手动在 ENS APP 中通过设置管理员来迁移这个名称。 此外，ENS 团队会自动地从原先的临时注册器（基于拍卖的注册器）迁移记录。临时注册器上还没有迁移的名称会在新部署的注册器自动创建，这些名称的有效期会被设置为 2020 年 5 月 4 日，也就是说这些名称不再需要用户手动迁移了。尽管如此，他们还是需要发送一笔交易来收回之前的押金，该操作不受时间限制。这样，ENS 的新注册器就可以完全与这个过时的注册器撇清关系了。 公共解析器 新版的公共解析器合约已经成功部署在这个地址：0x4976fb03C32e5B8cfe2b6cCB31c09Ba78EBaBa41 。该合约引用了新的 ENS 注册表，并附带实现了 “多重调用” 功能，允许用户通过一笔交易同时设置多条记录。 虽然使用旧版公共解析器的名称依旧可以正常解析，但由于公共解析器需要在 ENS 注册表中查询谁具有设置某个名称解析记录的权限，所以要想修改解析记录，就需要先迁移到新版公共解析器才行。ENS APP 利用 “多重调用” 功能来助力迁移进程，使得用户能够通过两笔交易完成一个名称所有解析记录的迁移：第一笔交易将所有解析记录从旧解析器复制到新解析器中，第二笔交易将名称在注册表中的记录指向新的解析器合约。 .eth 注册控制器 ENS 中所有 .eth 二级名称的注册请求都是通过 控制器合约 来处理的。迁移完成后，所有来自旧注册表和旧注册器的名称都在新注册表和新注册器中重新注册，ENS 团队将启用标准注册控制器，该控制器通过前后两笔交易完成一次注册。控制器合约与以前的部署没有任何变化。 反向注册器 新版反向注册器已经成功部署，并指向了新版注册器。与旧版本相比，没有任何变化。在整个迁移过渡期间，反向解析将继续正常工作。 DNSSEC 注册器 新版 DNSSEC 注册器已经成功部署。新版本保留了旧版本的所有功能，同时加入了一些改进，这些改进让 DNSSEC 支持更多顶级名称变得更为容易。.xyz 名称的解析会继续正常工作，但是这些名称的所有者如果需要更改名称的某些信息，就必须先通过 “claim” 过程收回名称的所有权。 子名称注册器 新版子名称注册器已经成功部署，该版本与之前的版本相比，除了支持这次迁移，基本没有变化。 © Pengfei Ni all right reserved，powered by GitbookUpdated at 2022-05-17 21:04:39 "}}